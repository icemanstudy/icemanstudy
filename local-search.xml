<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>android转web前端那些事</title>
    <link href="/2022/03/23/android%E8%BD%ACweb%E5%89%8D%E7%AB%AF%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2022/03/23/android%E8%BD%ACweb%E5%89%8D%E7%AB%AF%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>一转眼的功夫,新公司入职1年零3个月了,也算是成功从一个android原生开发转行到web前端开发了.一些小小感触:</p><h3 id="对于开发而言-转行真挺简单的"><a href="#对于开发而言-转行真挺简单的" class="headerlink" title="对于开发而言,转行真挺简单的."></a>对于开发而言,转行真挺简单的.</h3><p>刚来的时候一度以为是HR给我分错了部门,说好的车联网呢,android车机呢,怎么变成做web页面了?</p><p><img src="https://gitee.com/icemanbin/imagelib/raw/master/2022/20220323171709.png"></p><p>仅有的一个app还是用那个啥uniapp开发的,不就h5套壳应用么,这种上古hybrid方案我又不是没做过,还是自己开发的壳子.</p><p><em>给招聘的HR打电话了解了下,原来是他搞错了.这就比较尴尬了.</em></p><p>试用期转部门似乎也不太好,那就先从uniapp入手吧.</p><p>配环境,拉代码,再花晚上的加班时间看了总共2小时左右的教学视频,差不多就入手改bug了,真棒.</p><p>改了几天bug,就开始写新需求,copy一个页面,用改bug的思路去做,居然也做得有模有样.</p><blockquote><p>程序员两大法宝:ctrl+c和ctrl+v,诚不欺我.</p></blockquote><p>没过多久,遇到web前端的一个紧急需求,拉我去支持一下.也是硬着头皮上了,依旧是<strong>copy再改</strong>这个套路,边改边学.</p><blockquote><p>作为新手,能做的只是尽量把注释都写完整.</p></blockquote><p>说实在的,这种边学边做的模式,带来的是<strong>超高的学习效率</strong>.<br>跟前同事调侃:一年的时间就让我看起来像3年的开发经验~~~<br>后面由于改了几个性能优化点,在同事的眼中,已经是大佬了…</p><p>原因是什么呢,我细想了下:</p><ul><li>已经有过一门语言的经验在前,现在学习,会丢掉80%的语言相通部分,关注剩下的差异性部分,无形中起点高了很多很多.</li><li>web前端和原生前端,在渲染这一块,殊途同归,都是基于mvvm和事件驱动,在性能优化和疑难问题上,有着意料之中的精准直觉.</li></ul><h3 id="全栈也没啥了不起的"><a href="#全栈也没啥了不起的" class="headerlink" title="全栈也没啥了不起的."></a>全栈也没啥了不起的.</h3><p>一向觉得全栈是垃圾的我,如今也开启了第二技术栈.<br>对全栈的观点算是发生了一点点的变化吧:</p><ul><li>从技术角度,可以为了开辟新视角,便于领悟一些原本就殊途同归的东西而全栈,</li><li>从管理角度,可以为了扩大管理范围,防止外行知道内行而全栈,但万万不可以为了多做点业务需求而全栈.</li></ul><p>还是那句话:<strong>人的经历是有限的,各方面都精通的人并不存在</strong>.</p><blockquote><p>你可以多学几个技能,但是每个技能都想拿来吃饭,那我只能呵呵了.</p></blockquote><p>公司有位所谓的”全栈”工程师,前端后端都能做,然而其在两个端对应的”不全栈人士”看来,都是”小学生级别代码”…当然我并不是对这位同事有意见,只是觉得:挺适合小公司的.</p><h3 id="在大前端框架领域-web确实比原生优秀很多-但原因是关注点的区别"><a href="#在大前端框架领域-web确实比原生优秀很多-但原因是关注点的区别" class="headerlink" title="在大前端框架领域,web确实比原生优秀很多,但原因是关注点的区别."></a>在大前端框架领域,web确实比原生优秀很多,但原因是关注点的区别.</h3><p>最直接的感受:<br>做android的时候,对mvvm也只是有所了解.但并没有在项目中实施.结果到了web,发现已经是标配了.模板语言在这里发挥得淋漓尽致,比起android开启了databingding的xml都强了无数倍.</p><blockquote><p>web前端开发效率高不是没有道理的.</p></blockquote><p>原因也和关注点有关:<br>web前端更关注界面上的显示效果,开发人员的开发速度.<br>原生前端更关注界面的响应速度,软件的功能和稳定性.</p><ul><li>由于对宿主资源使用能力比不上网页,因此android需要考虑性能优化.</li><li>由于采取安装包形式,因此android诞生了各种热更新,插件化的黑科技.</li><li>由于需要对接硬件,android要关注比web多得多的api.</li></ul><p>举个例子:<br>网络库向来是原生开发中很重要的一个基础库.请求参数封装,线程池,连接和读写优化,响应解析,这些都是需要考虑的内容.</p><p>在web中呢?集成了常用了axios之后,基本上就做一下返回数据异常的处理就够了.</p><ul><li>线程池?浏览器已经给你定死了并发量.</li><li>数据解析?js中可以直接处理json.</li><li>读写优化?你都接触不到byte那一层.</li></ul><p>当然这并不是说web前端没有技术含量,技术含量在开发框架(比如vue这种)和打包阶段.但是前者基本也没有二次开发的必要,后者大多数业务都用不上.</p><h3 id="toB的业务相对toC-技术水平差不少"><a href="#toB的业务相对toC-技术水平差不少" class="headerlink" title="toB的业务相对toC,技术水平差不少."></a>toB的业务相对toC,技术水平差不少.</h3><p>这是最值得吐槽的地方.<br>之前的所有工作都是做toC的软件.用户量大,暴露的技术问题也多,产品也有专门的团队,有自己的想法.整个项目的节奏把握得也很好.</p><p><em>嗯,很美好,这才是互联网软件开发应该有的样子.</em></p><p>自从做了toC,一切都变了:</p><ul><li>用户量:日活100是常态.在这样的基数下,线上指标监控已经没什么意义了.</li><li>产品:都是用客户说了算.只要能让客户使用,客户提啥要求就做啥.</li><li>项目进度:还是客户说了算.</li><li>交互和UI:永远都是最低优先级,无关功能的东西,根本没有人在乎.</li></ul><blockquote><p>toB的软件,在前端侧,用户量已经和技术毫无关系了.</p></blockquote><p>这带来一个很严重的问题:</p><p><strong>长期做toB业务的,技能水平几乎毫无进步.</strong></p><p>这也是我一直以来在考虑的问题.</p>]]></content>
    
    
    <categories>
      
      <category>闲聊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iframe中关于cookie的操作</title>
    <link href="/2021/07/09/iframe%E4%B8%AD%E5%85%B3%E4%BA%8Ecookie%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/07/09/iframe%E4%B8%AD%E5%85%B3%E4%BA%8Ecookie%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论:"></a>先说结论:</h3><p>跨站的iframe中,写入对应cookie,需要设置<br><strong>SameSite=None; Secure</strong><br>否则无法写入成功</p><h3 id="相关细节"><a href="#相关细节" class="headerlink" title="相关细节"></a>相关细节</h3><h4 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h4><p>域名/端口/协议三者相同即为同一个域.</p><p>二级域名相同即为同一个站.</p><p>参考:<a href="https://cloud.tencent.com/developer/article/1751237">https://cloud.tencent.com/developer/article/1751237</a></p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>Strict,Lax,None三个属性用来控制对应cookie何时可以在请求中发送.</p><p>默认为Lax:跨站时,部分get请求可以携带cookie.</p><p>参考:<a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p><h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p>设置为Secure的cookie,仅在发起https请求时可以携带.<br>只有https页面可以使用Secure标记写入cookie.</p><h4 id="iframe的cookie写入"><a href="#iframe的cookie写入" class="headerlink" title="iframe的cookie写入"></a>iframe的cookie写入</h4><p>当iframe和父级页面为同站时,cookie写入正常<br>当iframe和父级页面为不站时,所有cookie无法写入<br>当iframe为https且使用<strong>SameSite=None; Secure</strong>时,才可以写入cookie.</p><p>参考:<a href="https://support.google.com/chrome/thread/33543699/document-cookie-is-not-working-with-iframe-windows-10-chrome-80-0-3987-132?hl=en">https://support.google.com/chrome/thread/33543699/document-cookie-is-not-working-with-iframe-windows-10-chrome-80-0-3987-132?hl=en</a></p><h3 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h3><p><a href="https://www.beski.in/demo/test-parent.html">https://www.beski.in/demo/test-parent.html</a></p><p>参考文档:<br><a href="https://juejin.cn/post/6844904095476613133">https://juejin.cn/post/6844904095476613133</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端跨平台技术演变漫谈</title>
    <link href="/2020/12/03/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E6%BC%94%E5%8F%98%E6%BC%AB%E8%B0%88/"/>
    <url>/2020/12/03/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E6%BC%94%E5%8F%98%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>作为原生前端的两大巨头,andorid和ios已经共存了十年,在可见的未来,还会一直存在下去.这给了所谓”跨平台”技术巨大的成长空间,毕竟成本分分钟降低一半,哪家公司不喜欢呢对不对?</p><p>作者2010年入行移动端开发,经历了历代跨平台技术的演进,总结下来,近十年的技术演变可分为三代.下面依次说说.</p><h3 id="第一代-web方式"><a href="#第一代-web方式" class="headerlink" title="第一代:web方式"></a>第一代:web方式</h3><p>其实这个严格上来说算不得什么跨平台,仅仅是依赖android和ios的framework中都具备的webview相关组件来实现的.</p><p>Webview也好,UIWebview也好,既然你都支持html+css+js那一套.那我就用这一套写呗,写完顺便还能发布h5版本.</p><p>然而web页面毕竟运行在web容器上,移动设备的很多特性都没有办法使用,例如摄像头,震动,打电话等等,又或者某些性能要求高的功能必须用原生方式做,因此当时的很多app都是原生和h5混着用,最不济也是要套个原生壳子,俗称混合开发.</p><p><strong>h5页面和原生页面的通信,h5页面和设备原生功能的交互,成了混合开发最核心的问题.</strong></p><p>在此基础上,衍生了很多成熟的跨平台框架,比如<a href="https://phonegap.com/">PhoneGap</a>,现在应该叫做Cordova了.</p><blockquote><p>PhoneGap 被 Adobe 收购了,但是剥离了核心代码贡献给 Apache Software Foundation,Apache 将这个项目命名为Cordova ,也就是说 PhoneGap 是基于 Cordova 的.</p></blockquote><p>PhoneGap是什么?是一个采用HTML,CSS和JavaScript的技术,创建移动跨平台移动应用程序的快速开发平台.简而言之就是一个能加载h5页面的壳子,但这个壳子与原生平台的webview组件不同的是,它帮你做了很多的原生功能交互,包括但不限于以下:</p><ul><li>加速计</li><li>摄像头</li><li>罗盘</li><li>通讯录</li><li>文档</li><li>地理定位</li><li>媒体</li><li>网络</li><li>通知(警告、声音和振动)</li><li>存储</li></ul><p>如果有更多的需求,还可以自己开发插件.</p><p>然而这种方式终究还是走的web渲染方式,由于其运行机制和代码冗余的原因,在加载体验和交互体验上比不过原生,因此当时也仅作为一些活动页面的展现方式,来弥补原生页面修改不够灵活的缺点.</p><h3 id="第二代-RN-Weex方式"><a href="#第二代-RN-Weex方式" class="headerlink" title="第二代:RN/Weex方式."></a>第二代:RN/Weex方式.</h3><p>既然web渲染机制存在性能上的问题,那能不能继续使用原生渲染方式呢?</p><p>基于第一代跨平台技术存在的缺点,Fackbook想到了一种名为<a href="https://reactnative.cn/">ReactNative</a>的解决方案:我用js写页面,但是在不同平台上转换成对应的原生控件.</p><p><img src="https://i.loli.net/2020/12/11/hcWKSvHk16gyeFX.png"></p><p>不得不说这种想法真的很棒,既照顾了开发效率,又满足了性能要求,仅仅需要为两个端各开发一套转化框架就行了,这个工作是一次性的!</p><p>自2015年发布以来,Facebook不遗余力的投入对ReactNative的建设.逐渐有了越来越多的公司开始采用这一方案.随后2016年阿里也发布了Weex框架,开始有了一批阿里系的使用者.</p><p>看似很完美的方案,但截至2020年,已经有越来越多的公司放弃RN,回归原生技术栈.原因是RN的一些缺点:</p><ul><li>无法完全跨平台,简而言之,只要遇到同一类型控件在两个平台有差异的就要区别对待.</li><li>性能问题一直存在.比如臭名昭著的android平台列表item内存释放.</li><li>扩展性依然不够,相对于原生控件的各种api,支持得不够彻底.</li><li>用作页面级开发时,回退栈和tab处理依然不够完美.比如android中的启动模式.</li></ul><h3 id="第三代-Flutter方式"><a href="#第三代-Flutter方式" class="headerlink" title="第三代:Flutter方式"></a>第三代:Flutter方式</h3><p>一套代码,运行时转化成多个端的原生控件,机制上行得通,但是里面的坑已经被大家摸得差不多了.在这个过程中,有人放弃,有人坚持,不可否认的是:这依然是一个不完美的方案.</p><p>2018年12月,Google正式发布Flutter.这个就nb了,直接操作底层的2D绘图引擎进行绘制.</p><blockquote><p>什么控件转换,不存在的,我直接画出来!</p></blockquote><p>Android系统上默认的2d绘图使用的是skia引擎.Flutter使用dart语言来写界面,最后直接操作skia引擎进行绘制,完全绕过原生自带的那一套ViewGroup机制,运行起来就是一个大大的View.</p><p>ios怎么办呢?简单粗暴,直接打包一个skia引擎上去…<em>(所以目前ios上的安装包大小和性能都被人吐槽.)</em></p><p>直接操作渲染引擎,从根本入手,在我看来这是当之无愧的第三代跨平台技术了.时至今日,Flutter版本在不断的优化和bug修复中已经更新到了1.22,也有了一些大厂的背书,最典型是闲鱼团队(<em>据说某个开发人员在Flutter上提交的PR比Flutter自身的开发人员还多.</em>).近几年的各种开发者大会,移动端会场也是动辄Flutter.</p><p>除了Flutter for ios,还有<a href="https://flutter.cn/web">Flutter for web</a>,主要基于HTML+CSS+Canvas的方式,实现传统web页的展示.</p><blockquote><p>一切看起来都在向好的方向发展,在这个看起来大一统的技术下,整个大前端终于要统一了么?</p></blockquote><h3 id="泼冷水"><a href="#泼冷水" class="headerlink" title="泼冷水"></a>泼冷水</h3><h4 id="1-Flutter并不是什么高科技-类似的理念在游戏开发中已经有了"><a href="#1-Flutter并不是什么高科技-类似的理念在游戏开发中已经有了" class="headerlink" title="1.Flutter并不是什么高科技.类似的理念在游戏开发中已经有了."></a>1.Flutter并不是什么高科技.类似的理念在游戏开发中已经有了.</h4><p>游戏开发用什么技术?3d用Cocos2d-x,3d用Unity3D.为什么一套技术能在android和ios上都跑起来呢?无非就是底层用的都是<strong>OpenGL ES</strong>.</p><blockquote><p>OpenGL ES（OpenGL for Embedded Systems）是三维图形应用程序接口OpenGL的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p></blockquote><p>Android 支持多版 OpenGL ES API：</p><ul><li>OpenGL ES 1.0 和 1.1 - 此 API 规范受 Android 1.0 及更高版本的支持.</li><li>OpenGL ES 2.0 - 此 API 规范受 Android 2.2（API 级别 8）及更高版本的支持.</li><li>OpenGL ES 3.0 - 此 API 规范受 Android 4.3（API 级别 18）及更高版本的支持.</li><li>OpenGL ES 3.1 - 此 API 规范受 Android 5.0（API 级别 21）及更高版本的支持.</li></ul><p>ios中的OpenGL ES框架则提供了OpenGL ES规范的1.1、2.0和3.0版本的实现.</p><p>是不是很熟悉?同样是利用手机内置的渲染引擎,google非常机智的使用dart framework做了一层封装,对接android上自带的skia.</p><p>也许dart framework提供了更丰富的api,对上层开发者来说更加友好,也许dart语法比c++写起来更舒服.甚至skia在绘制2d图像上性能比opengl更好.但无论如何,这种思想是一样的:放弃各自平台的framework api,直接绘制.</p><h4 id="2-Dart语法需要重新学习-且缩进层级太深-可读性不佳"><a href="#2-Dart语法需要重新学习-且缩进层级太深-可读性不佳" class="headerlink" title="2.Dart语法需要重新学习,且缩进层级太深,可读性不佳."></a>2.Dart语法需要重新学习,且缩进层级太深,可读性不佳.</h4><p>Dart作为一种新兴语言,综合了java,js,python等各种语言的优点.是好是坏暂不评价,但是毫无疑问:是有一些上手门槛的.</p><p><img src="https://i.loli.net/2020/12/14/aIzGqitwmbAjKWR.png"></p><p>在Flutter中,UI界面不再使用xml或者xib方式,而是使用Dart语言来书写.然而页面是有层级的,Dart中如何展示层级?</p><blockquote><p>使用缩进.</p></blockquote><p>用缩进来控制代码格式,并不新鲜,例如python.但是一旦页面层级太多…</p><p>先感受一下吧,这是一个非常简单的页面,仅显示了一个多选框和一个文本:</p><p><img src="https://i.loli.net/2020/12/14/4apvWZCfjs739n2.png"></p><p>虽然可以通过各种控件封装来降低单个代码中的嵌套层数.但界面和业务逻辑混杂在一起仍然无法避免.</p><blockquote><p>StateFulWidget很有效的实现MVVM思想,解决了性能问题,但无法解决语法层面上的代码耦合.</p></blockquote><h4 id="3-在android以外的平台上-没有太多优势"><a href="#3-在android以外的平台上-没有太多优势" class="headerlink" title="3.在android以外的平台上,没有太多优势."></a>3.在android以外的平台上,没有太多优势.</h4><p>除了android自带skia,可以无缝接入Flutter,在web上需要调用canvas进行绘制,存在兼容性问题,在ios上则要将整个skia打包,将面对Apple应用商店对于安装包大小的限制.</p><p>目前据我所知,在ios平台上试水flutter的工程大大低于android平台,web上则几乎没有.<br>如果只在一个平台上使用flutter,那所谓的跨平台还有何意义?</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>最终,很多公司最终还是选择了原生+h5的方式.毕竟老技术已知优缺点,经得起考验.<br>在此基础上诞生了各种各样的<strong>小程序</strong>,同时对于web容器的深度技术挖掘也一直在进行中.</p><p>同时基于第二代技术的轻量化方案也慢慢出现在大众的视野:</p><blockquote><p>使用内部统一描述语言对页面进行描述,由各平台转化成原生控件,整个解析和渲染方案按照公司内部约定执行,慢慢扩展新功能.</p></blockquote><p>可以参考另一篇文章:<a href="https://icemanbin.gitee.io/2020/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">动态渲染技术</a>.</p><p>总而言之:跨平台技术还有很长的路要走,技术终究是实现业务发展的平台,没有优劣之分,慢慢观望吧.</p>]]></content>
    
    
    <categories>
      
      <category>跨平台</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>聊聊架构师角色</title>
    <link href="/2020/12/02/%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%92%E8%89%B2/"/>
    <url>/2020/12/02/%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E5%B8%88%E8%A7%92%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<p>架构师是什么?听起来很牛逼的岗位.实际上但凡有设置这个岗位的公司,其内部等级也确实是比较高的.</p><p>根据作者经历的公司总结,开发岗位的职级大致如下.</p><p><img src="https://i.loli.net/2020/12/08/OYsPD84dMaUbxRW.png"></p><p>如图,高级开发工程师之后,程序员的发展路线就开始出现分支,其中开发经理角色属于管理岗位,其他两个则属于技术岗位,类似公司职级类型中的M和P序列.</p><p>虽然很多公司在P序列并没有区分架构师和技术专家,但从实际工作而言,其实两者有很大的区别.对于人员分配合理的团队,必然会对两者进行区分,甚至通过归属不同团队来规划工作内容.</p><p>以下为作者自己的感受,通过两大角色的区别,来解释何为架构师.关于正式的解释,可以参考<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/3473607?fromtitle=%E6%9E%B6%E6%9E%84%E5%B8%88&fromid=8281290&fr=aladdin">架构师</a>.</p><h3 id="架构师的工作是宏观的-技术专家的工作是微观的"><a href="#架构师的工作是宏观的-技术专家的工作是微观的" class="headerlink" title="架构师的工作是宏观的,技术专家的工作是微观的."></a>架构师的工作是宏观的,技术专家的工作是微观的.</h3><p>一套系统的稳定性和扩展性,很大程度上决定于整体架构,从这方面来讲,架构师的视野是全局的,其关注的是各部件之间的协作.</p><ul><li>A和B能否高效合作?是否需要调整接口?</li><li>X功能的实现,应该挑选哪种技术?有哪些方案可以选择?</li><li>各组件的分工是否符合当前业务部门人力安排?</li></ul><p>对于整个系统的下一级单元的内部实现,并不是架构师的关注内容.这一部分将由对应的业务领域专家去管理.</p><p>作为整体系统的一份子,各个子模块需要能稳定可靠的对外输出,同时具备一定的性能,这就是对应技术专家的研究内容.很多事情都是60分的努力可以达到80分的效果,但90分的效果则需要100分的努力.在这个方向上,兴趣+天赋+努力,缺一不可.虽然太过专精导致就业面稍显狭隘,但在真正需要时,往往是无可取代.这也是为什么有些小众岗位薪资巨高,却招不到人的原因.</p><h3 id="架构师的知识储备是广阔的-技术专家的知识储备是专精的"><a href="#架构师的知识储备是广阔的-技术专家的知识储备是专精的" class="headerlink" title="架构师的知识储备是广阔的,技术专家的知识储备是专精的."></a>架构师的知识储备是广阔的,技术专家的知识储备是专精的.</h3><p>人的精力是有限的,广度和深度往往只能二选一.架构师既然要放眼全局,那必然只能优先往广而全方向发展,什么都要懂.</p><p>幸运的是:软件设计殊途同归,高级开发语言也是一通百通,某种意义上来说,程序员之间其实很容易形成共鸣.因此这里的”懂”,其实并非是要能够开展研究并有所建树,而是能够通过统一的分析模型快速理解并吸收,然后加以应用.</p><p>换句话来说:</p><blockquote><p>这个东西你能研究出来确实了不起,我自愧不如,但是你一讲我就懂了.</p></blockquote><h3 id="架构师是指引方向的-技术专家是解决问题的"><a href="#架构师是指引方向的-技术专家是解决问题的" class="headerlink" title="架构师是指引方向的,技术专家是解决问题的."></a>架构师是指引方向的,技术专家是解决问题的.</h3><p>这个是他人视角里最大的区别点.</p><p>架构师给人的感觉就是高谈阔论,动辄在PPT中”指点江山,激扬文字”,也难怪市面上产生了不少所谓”PPT架构师”…</p><p>现有的系统能够满足将来的业务需求?<br>针对可能的业务需求,应如何调整系统架构,以快速扩展新的功能模块?<br>根据现有的技术能力,可以提出哪些业务发展方向的建议?</p><blockquote><p>看到没有,这就是未来的CTO.</p></blockquote><p>技术专家就大不一样了,往往都是很”平易近人”的,一个能够解决问题的”大佬”比成天鼓捣”不着地”设计的”架构师”要有人气得多.</p><ul><li>硬核优化需求,找大佬!</li><li>这个问题搞不定啊,找大佬!</li><li>这个方案咋样,找大佬看看!</li></ul><p>在长年累月的疑难杂症解决过程中,进一步锻炼了自己的硬实力,提升了他人眼中的印象分,而这些分数,又反过来形成更多”疑难杂症”的吸铁石,促进自己继续进步.</p><p>这样一个<strong>滚雪球</strong>的发展轨迹,往往是那些知名大佬共同的经历.换句话说,如果你不想成为一辈子写业务代码的”工具人”,那么在你参加工作两年以后,一定要好好把握机会,营造出”牛人”的形象,别管能不能解决,先做”问题吸铁石”再说,做得好的话,一年胜似三年.</p><p>看到这里,想必你对架构师有了更深层次的理解,对自身的职业发展也有了一些规划,希望大家早日成为理想中的角色!</p>]]></content>
    
    
    <categories>
      
      <category>闲聊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gitee+hexo+smms打造免费个人博客</title>
    <link href="/2020/12/01/gitee-hexo-smms%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/12/01/gitee-hexo-smms%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p> 博客,英文名blog,大部分时候,是一个对外分(zhuang)享(bi)的地方.</p><p> 初为程序员的时候,也曾在csdn,博客园上面写过一些文章.后期由于上网需要接触了vps,借着服务商的支持,一键安装了wordpress,再买个域名,开始折腾”真正”的个人博客.之后看到掘金,简书之类的新生代博客平台,往往嗤之以鼻:”这不就是文艺青年版csdn么?”</p><p> 随着热情慢慢减退,自建vps变成直接使用机场,个人博客也随之关闭,加之名利之心看淡,开始寻找一个真正可以记录一些东西,又不用花太多功夫打理的地方.再说了,互联网的世界,不白嫖一波还能叫程序员?</p><hr><p>本文记录一下免费博客的组成,最终效果可以参考本博客,如假包换,童叟无欺.</p><p> 总体来说,一篇文章从产生到让互联网上的观众看到,有三个步骤:<br> <strong>写作&gt;生成&gt;部署</strong></p><p><img src="https://i.loli.net/2020/12/01/ily1SYcpaZsqbHL.png"></p><h2 id="文章写作"><a href="#文章写作" class="headerlink" title="文章写作"></a>文章写作</h2><h3 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h3><p><strong>Markdown</strong></p><p> 作为目前程序员届通用的文档标记语言,其特性这里就不多说了.<a href="https://zh.m.wikipedia.org/zh-hans/Markdown">介绍在此</a>.</p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>个人选择Markdown编辑器的重要指标依次排序:</p><ol><li>实时预览</li><li>便捷的工具条</li><li>左右分栏显示</li></ol><p>符合条件的专用编辑器应该不少,这里推荐一个”一物多用”的工具:有道云笔记.</p><p>作为一款免费云笔记,不知从什么时候开始,其居然开始支持md编辑,并且还有非常方便的工具条.</p><p><img src="https://i.loli.net/2020/12/01/3G5FfDP96sAeW1K.png"></p><p>目前在移动端没有办法查看md文档,但是如果仅用来写作,已经完全够用了.</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>图片存放于何处,是每一个博客都绕不过去的话题.</p><p>SM.MS在众多收费图床中是一股清流.</p><p><img src="https://i.loli.net/2020/12/01/u8OHiKC31LTZvop.png"></p><p>免费用户5G空间,单图片限制5MB,每分钟最多上传20张.完全够用了.</p><p>重点是:<strong>支持API上传</strong>.这个妙用后面再讲.</p><p>图片的来源有很多,有本地文件,也有截图,如果用GUI方式上传,还涉及到命名问题,易混淆.那么有没有更方便的上传方式呢?</p><h3 id="图片上传工具"><a href="#图片上传工具" class="headerlink" title="图片上传工具"></a>图片上传工具</h3><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>: 一个用于快速上传图片并获取图片 URL 链接的工具.</p><p><img src="https://i.loli.net/2020/12/01/rbaFq6nB8JxKtNW.png"></p><p>本地文件拖动上传这种小儿科操作就不说了.</p><p>微信/QQ等通讯软件使用快捷键截图后,直接点击即可上传,并自动复制md格式图片地址,在实际使用中尤其方便.</p><p><img src="https://i.loli.net/2020/12/01/1XLv7cAOBaPx9sn.png"></p><p>其支持的图床中,要么需要收费,要么需要绑定域名,唯独前面所说的SM.MS都不需要.完美.</p><p>使用起来也很简单,去图床上申请token,填入picgo即可.</p><p><img src="https://i.loli.net/2020/12/01/Ztq7RfvehUDGJ1m.png"></p><h2 id="页面生成"><a href="#页面生成" class="headerlink" title="页面生成"></a>页面生成</h2><p>借助各种编辑器,md的本地预览是没有问题的,但是想在网页上展示,需要将其转换成html页面.</p><p>本文使用的是<a href="https://hexo.io/zh-cn/">hexo</a>,基于nodejs开发,操作简单,而且有各种主题支持.</p><p><img src="https://i.loli.net/2020/12/01/GxIt4CRpi2L3rJs.png"></p><p>顺便介绍本文使用的主题:<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>,卡片布局,简单大气.</p><h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><p><a href="https://docs.github.com/cn/free-pro-team@latest/github/working-with-github-pages/about-github-pages">GitHub Pages</a>提供了静态页面托管.只需要在自己空间中建立一个和用户名相同的项目即可.</p><p><img src="https://i.loli.net/2020/12/01/OCqdwuFYHh5BLGm.png"></p><p>但是由于网络原因,部署在GitHub Pages上的页面通常打开速度不是很理想.这里本文使用了国内替代品:<a href="https://gitee.com/help/articles/4136">Gitee Pages</a>.</p><p><img src="https://i.loli.net/2020/12/01/ETbRP91F32IMDfX.png"></p><p>与GitHub Pages相比,唯一的缺点是不能自动发布(做成收费功能了…),需要进入项目的服务页面,手动点击更新.</p><p><img src="https://i.loli.net/2020/12/01/M6qaFRrDVojPIQl.png"></p><p>相对于文章发布的低频率,可以忍受.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Gitee Pages提供部署容器.</li><li>Hexo提供页面生成技术.</li><li>PicGo提供快捷图片上传和使用,支持多个图床.</li><li>有道云笔记提供Markdown编辑器功能.</li></ul><hr><p>2020.12.17更新.</p><p>用下来发现Gitee速度挺快.加之Picgo又有第三方开发的Gitee图床插件.于是将图床从sm.ms换成gitee.<br>注意:据说gitee上传图片不能超过1m,日常截图上传不用担心.</p><p>插件使用方式:</p><ol><li>Gitee新建一个仓库.记得初始化master分支,仓库设置为<strong>公开</strong>.</li><li>picgo-插件设置中搜索”gitee”,安装图中所示的即可.<br><img src="https://gitee.com/icemanbin/imagelib/raw/master/20201217092144.png"></li><li>安装完毕后,”图床设置”中会出现Gitee图床.按图配置.<br><img src="https://gitee.com/icemanbin/imagelib/raw/master/20201217092506.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>闲聊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象基本原则的逆向解析</title>
    <link href="/2020/09/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E7%9A%84%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/09/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E7%9A%84%E9%80%86%E5%90%91%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>作为一个java出身的程序员,面向对象这个概念可谓是耳濡目染.三大特征和五大原则也理当倒背如流,但理论归理论,该如何与实践相结合呢?</p><p>拿java的设计模式举例,说来惭愧,至今我也没能完整背出传说中的23种,甚至有些都没有用过.然而我们真的需要在写代码前,像挑选工具一样,先选中一种设计模式,然后去套用吗?</p><blockquote><p>程序员的思想应该是天马行空,不受拘束的.</p></blockquote><p>一段优美的代码,一个优秀的框架,<strong>绝不是因为其使用了何种设计模式</strong>,而是因为其是当时环境下最合适的方案,换句话来说,<strong>软件开发没有教条,使用方说好才是真的好.</strong></p><p>设计模式如此,那设计原则呢?虽然是一个更为宽泛的概念,死记硬背也废不了多少脑细胞.但就如同前面所说,带着这样的桎梏写代码,终究是落了下乘.理想中的状态,应该是在完全理解后,信手拈来,融会贯通,如武侠小说一样,”手中无剑,心中有剑”的地步.</p><p>那么如何能做到<strong>完全理解</strong>?在我看来,最熟悉事物的必然是其创作者,如果藉由开发过程中的感悟,整理出一套类似的基本原则,必能大大提升对其理解程度.</p><p>说了这么多,下面进入正文,从软件开发的源头开始,探究基本原则的诞生.</p><p>以下为作者在多年代码阅读,架构设计中的体会,可能存在理解上的谬误.请自行去芜存菁.</p><hr><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>每一个软件空间都如同一个小宇宙,初始一片空白.</p><p><img src="https://i.loli.net/2020/12/04/pmfZsPcagu3kHht.png"></p><p>造物主写下第一个Class.这个类开始有了自己成员变量,自己的方法,换句话说,在这个小宇宙里,有了自己的职责.<br><img src="https://i.loli.net/2020/12/04/ILBJtzY3jkFbM1a.png"></p><p>既然有”类”这个概念,那么其包含的内容应该是高度内聚的,是你的任务,就需要你独立完成,不然”要你何用”?<br><img src="https://i.loli.net/2020/12/04/HAN5DeQhowsn96r.png"></p><p><strong>单一职责原则:</strong></p><blockquote><p>一个类应该只负责一件事情.</p></blockquote><h3 id="扩张"><a href="#扩张" class="headerlink" title="扩张"></a>扩张</h3><p>一个类显然是不够的,成熟的软件往往由成千上万个类”合作”完成其功能.而类与类之间的关系,根据UML中的定义,分为以下六种:</p><ul><li>继承</li><li>实现</li><li>依赖</li><li>关联</li><li>聚合</li><li>组合</li></ul><p>实际上,个人认为从更宽泛的角度而言,可以分为两类关系:</p><ul><li>传承/纵向关系:继承/实现</li><li>合作/横向关系:依赖/关联/聚合/组合</li></ul><p><img src="https://i.loli.net/2020/12/04/J39YwXbNhMfTLvC.png"></p><p><strong>纵向</strong>:实现和继承,分别对应interface和class,在java中都可以用instanceof来判断,下级相对于上级有非常明确的目的性.</p><p><strong>横向</strong>:四种关系只对应了关系的强与弱.本质上是多个不同用途的类,为了某个整体目的,融合在一起.</p><p>那么在不同方向上增加类时,应该如何设计呢?</p><h4 id="纵向发展"><a href="#纵向发展" class="headerlink" title="纵向发展"></a>纵向发展</h4><p>当我们需要修改类的某个方法实现时应该怎么做?</p><blockquote><p>直接修改源码?</p><p>这会造成当前类难以维护,可回退性是技术方案实施过程中的一个重要指标,况且你怎么知道将来不会改回来?</p></blockquote><p>正常做法是,对当前类进行扩展,对需要修改的方法进行扩展实现,然后替换到具体的使用场景中.</p><p><strong>开闭原则</strong></p><blockquote><p>改实现请扩展,别改我源码.</p></blockquote><p>替换,就意味着除了需求涉及部分,其他功能应该和替换前保持完全一致,那么就产生了另一个要求:</p><p><strong>用于替换的子类,必须可以完全替代父类,不能让使用方有任何执行上的调整.</strong></p><p>从语法上来说,java天生的继承和实现机制已经足以保证子类和实现类可以做到编译时完全替换,但是运行时呢?</p><p>举个例子:</p><blockquote><p>类A有方法a和方法b两个方法,其中方法a使用到了方法b的执行结果.类B继承了类A,重写了 b方法,返回了null,此时使用类B替换类A,从语法上来说没有问题,但是执行时会出现意料之外的结果.</p></blockquote><p>在实际使用中,这种情况并不少见,往往因为代码规范或者业务逻辑,产生多个关联性极强的方法,子类在重写时却并不知道其关联度,进而导致在替换父类时出现意外.</p><p><strong>替换的方式给维护带来了便利,但同时也带来了潜在的不稳定性.</strong></p><p>所幸的是,java提供了抽象方法,将留给子类重写的方法设置为抽象方法,由子类自行管理:</p><ul><li>可重写方法用抽象方法代替.</li><li>不可重写方法设置为private或者final.</li></ul><p><strong>里氏替换原则</strong></p><blockquote><p>所有非抽象方法的重写其实都是不合理的.</p></blockquote><h4 id="横向发展"><a href="#横向发展" class="headerlink" title="横向发展"></a>横向发展</h4><p>依赖/关联/聚合/组合,这几类只是关联关系的不同强弱等级.</p><p>既然有关联,就有耦合,前面也说过,使用替换的方式,可以快速的进行功能实现上的修改.此处替换的方式,实际上就是基于抽象编程,而非基于实现编程.</p><p><img src="https://i.loli.net/2020/12/07/6jNrPf75ASqeQs3.png"></p><p><strong>依赖反转原则</strong></p><blockquote><p>依赖接口而不是具体实现类</p></blockquote><p>与此同时,接口的设计便成为一个值得考虑的问题.</p><p>是将关联方法设计到一个大接口中,还是拆成多个不同接口?</p><p>先就大接口方式举一个例子:接口I有a,b,c,d,e方法.类A只依赖了接口I的a,b,c方法,B是A中接口I的实现类.类C依赖了接口I的d,e方法,D是C中接口I的实现类.此时B需要实现不需要的方法d和e,D则需要实现不需要的方法a,b,c.这是一个非常浪费的设计.</p><p>显然根据其类别,设计成不同的接口,做精细的控制是更好的选择.接口应该是<strong>一类方法的集合</strong>,类与类之间的依赖应该建立在最小的接口上,庞大而臃肿的接口应该进行拆分.</p><p><img src="https://i.loli.net/2020/12/07/oErvsDjkiMAKQpg.png"></p><p><strong>接口隔离原则</strong></p><blockquote><p>接口应该按照功能进行拆分</p></blockquote><p>至此,五大原则已经跃然纸上.知其然,更要知其所以然.回头再看看设计模式,无非都是在具体的使用场景下,根据基本原则设计出来的通用方案.只要心中谨记基本原则,不论何时何地,都可以创作出自己的设计模式.</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>关于”五大原则”,”六大原则”,”七大原则”:</p><p>相对于上述五大原则,多出来的两个分别是:</p><p><strong>迪米特法则</strong></p><blockquote><p>一个对象应当对其他对象有尽可能少的了解</p></blockquote><p><strong>组合复用原则</strong></p><blockquote><p>尽量使用对象组合与聚合，而不是继承</p></blockquote><p>在我看来,不管是五还是六还是七.都只是对设计原则的不同理解:</p><ul><li>迪米特法则,是依赖反转原则应用后的必然结果.</li><li>组合复用原则,则是在横向发展与纵向发展中做出的取舍:组合相对于继承,可以随意拆分,具备更高的灵活度,降低了代码层次,从目的上来说,与接口隔离原则有着异曲同工之妙.</li></ul><hr><p>软件设计发展至今日,已经有了很多前人的优秀经验,若想站在巨人的肩膀上,直接飞上去是不行的,那一定得是一步步爬上去.</p><p>谨以此篇文章记录编码感悟.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章看懂什么是微服务</title>
    <link href="/2020/09/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9C%8B%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2020/09/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9C%8B%E6%87%82%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>作者：老刘<br>链接：<a href="https://www.zhihu.com/question/65502802/answer/802678798">https://www.zhihu.com/question/65502802/answer/802678798</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>本文将介绍微服务架构和相关的组件，介绍他们是什么以及为什么要使用微服务架构和这些组件。本文侧重于简明地表达微服务架构的全局图景，因此不会涉及具体如何使用组件等细节。</p><p>要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。本文将以一个网上超市应用为例来说明这一过程。</p><h3 id="最初的需求"><a href="#最初的需求" class="headerlink" title="最初的需求"></a>最初的需求</h3><p>几年前，小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。</p><p>我们整理一下功能清单：</p><p>网站：</p><ul><li>用户注册、登录功能</li><li>商品展示</li><li>下单</li></ul><p>管理后台：</p><ul><li>用户管理</li><li>商品管理</li><li>订单管理</li></ul><p>由于需求简单，小明左手右手一个慢动作，网站就做好了。管理后台出于安全考虑，不和网站做在一起，小明右手左手慢动作重播，管理网站也做好了。总体架构图如下：</p><p><img src="https://pic4.zhimg.com/50/v2-72023eb73961d33d560cd4419f803103_hd.jpg?source=1940ef5c"></p><p>小明挥一挥手，找了家云服务部署上去，网站就上线了。上线后好评如潮，深受各类肥宅喜爱。小明小皮美滋滋地开始躺着收钱。</p><p>随着业务发展……好景不长，没过几天，各类网上超市紧跟着拔地而起，对小明小皮造成了强烈的冲击。在竞争的压力下，小明小皮决定开展一些营销手段：</p><ul><li>开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。</li><li>拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。</li><li>精准营销。利用历史数据对用户进行分析，提供个性化服务。</li><li>……</li></ul><p>这些活动都需要程序开发的支持。小明拉了同学小红加入团队。小红负责数据分析以及移动端相关开发。小明负责促销活动相关功能的开发。</p><p>因为开发任务比较紧迫，小明小红没有好好规划整个系统的架构，随便拍了拍脑袋，决定把促销管理和数据分析放在管理后台里，微信和移动端APP另外搭建。通宵了几天后，新功能和新应用基本完工。这时架构图如下：</p><p><img src="https://pic2.zhimg.com/50/v2-1292f5a391142ac8da195787e28291bf_hd.jpg?source=1940ef5c"></p><p>这一阶段存在很多不合理的地方：</p><ul><li>网站和移动端应用有很多相同业务逻辑的重复代码。</li><li>数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。</li><li>单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。</li><li>管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。</li><li>数据库表结构被多个应用依赖，无法重构和优化。</li><li>所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。</li><li>开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。为了减轻发布可能产生的问题的影响和线上业务停顿的影响，所有应用都要在凌晨三四点执行发布。发布后为了验证应用正常运行，还得盯到第二天白天的用户高峰期……</li><li>团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。</li></ul><p>尽管有着诸多问题，但也不能否认这一阶段的成果：快速地根据业务变化建设了系统。不过<strong>紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策</strong>。在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。</p><h3 id="是时候做出改变了"><a href="#是时候做出改变了" class="headerlink" title="是时候做出改变了"></a>是时候做出改变了</h3><p>幸好小明和小红是有追求有理想的好青年。意识到问题后，小明和小红从琐碎的业务需求中腾出了一部分精力，开始梳理整体架构，针对问题准备着手改造。</p><blockquote><p>要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以致于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……</p></blockquote><p>在编程的世界中，最重要的便是抽象能力。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：</p><ul><li>用户服务</li><li>商品服务</li><li>促销服务</li><li>订单服务</li><li>数据分析服务</li></ul><p>各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：</p><p><img src="https://pic1.zhimg.com/50/v2-0882bc64f3f20939876d3433e51fad72_hd.jpg?source=1940ef5c"></p><p>这个阶段只是将服务分开了，数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：</p><ul><li>数据库成为性能瓶颈，并且有单点故障的风险。</li><li>数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。</li><li>数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。</li></ul><p>如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：</p><p><img src="https://pic2.zhimg.com/50/v2-90388920d31fe35b791c6a92f758db18_hd.jpg?source=1940ef5c"></p><p>完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。</p><blockquote><p>还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。</p></blockquote><p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。</p><p>从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。改造完成后，小明和小红分清楚各自的锅。两人十分满意，一切就像是麦克斯韦方程组一样漂亮完美。</p><p>然而……</p><h3 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h3><p>春天来了，万物复苏，又到了一年一度的购物狂欢节。眼看着日订单数量蹭蹭地上涨，小皮小明小红喜笑颜开。可惜好景不长，乐极生悲，突然嘣的一下，系统挂了。</p><p>以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而<strong>微服务架构整个应用分散成多个服务，定位故障点非常困难</strong>。小明一个台机器一台机器地查看日志，一个服务一个服务地手工调用。经过十几分钟的查找，小明终于定位到故障点：促销服务由于接收的请求量太大而停止响应了。其他服务都直接或间接地会调用促销服务，于是也跟着宕机了。在微服务架构中，<strong>一个服务故障可能会产生雪崩效用，导致整个系统故障</strong>。其实在节前，小明和小红是有做过请求量评估的。按照预计，服务器资源是足以支持节日的请求量的，所以肯定是哪里出了问题。不过形势紧急，随着每一分每一秒流逝的都是白花花的银子，因此小明也没时间排查问题，当机立断在云上新建了几台虚拟机，然后一台一台地部署新的促销服务节点。几分钟的操作后，系统总算是勉强恢复正常了。整个故障时间内估计损失了几十万的销售额，三人的心在滴血……</p><p>事后，小明简单写了个日志分析工具（量太大了，文本编辑器几乎打不开，打开了肉眼也看不过来），统计了促销服务的访问日志，发现在故障期间，商品服务由于代码问题，在某些场景下会对促销服务发起大量请求。这个问题并不复杂，小明手指抖一抖，修复了这个价值几十万的Bug。</p><p>问题是解决了，但谁也无法保证不会再发生类似的其他问题。微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：</p><ul><li>微服务架构整个应用分散成多个服务，定位故障点非常困难。</li><li>稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。</li><li>服务数量非常多，部署、管理的工作量很大。</li><li>开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。</li><li>测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。</li></ul><p>小明小红痛定思痛，决心好好解决这些问题。对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。</p><p><img src="https://pic3.zhimg.com/50/v2-9e24974c29f3a57ef1bdc5ea47c59566_hd.jpg?source=1940ef5c"></p><h3 id="监控-发现故障的征兆"><a href="#监控-发现故障的征兆" class="headerlink" title="监控 - 发现故障的征兆"></a>监控 - 发现故障的征兆</h3><p>在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p><p>微服务架构中组件繁多，各个组件所需要监控的指标不同。比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</p><p>大部分组件都不需要自己动手开发，网络上有开源组件。小明下载了RedisExporter和MySQLExporter，这两个组件分别提供了Redis缓存和MySQL数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的指标接口。然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：</p><p><img src="https://pic2.zhimg.com/50/v2-ab2479317923472e06d5f3e0b8943944_hd.jpg?source=1940ef5c"></p><h3 id="定位问题-链路跟踪"><a href="#定位问题-链路跟踪" class="headerlink" title="定位问题 - 链路跟踪"></a>定位问题 - 链路跟踪</h3><p>在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。</p><p>我们用一个Istio文档里的链路跟踪例子来看看效果：</p><p><img src="https://picb.zhimg.com/50/v2-c1e791200de645b39ed670f9b86109e8_hd.jpg?source=1940ef5c"></p><p>从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：</p><p><img src="https://pic2.zhimg.com/50/v2-da001bd5ae83cd8fbcca1dec0db8dc24_hd.jpg?source=1940ef5c"></p><p>要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：</p><ul><li>traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。</li><li>spanId：标识一次服务调用的ID，即链路跟踪的节点ID。</li><li>parentId：父节点的spanId。</li><li>requestTime &amp; responseTime：请求时间和响应时间。</li></ul><p>另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。</p><p><img src="https://pic3.zhimg.com/50/v2-c1ac0f0772b5ddedafa44636e75b3ded_hd.jpg?source=1940ef5c"></p><p>以上只是一个极简的说明，关于链路跟踪的理论依据可详见Google的Dapper</p><p>了解了理论基础后，小明选用了Dapper的一个开源实现Zipkin。然后手指一抖，写了个HTTP请求的拦截器，在每次HTTP请求时生成这些数据注入到HEADERS，同时异步发送调用日志到Zipkin的日志收集器中。这里额外提一下，HTTP请求的拦截器，可以在微服务的代码中实现，也可以使用一个网络代理组件来实现（不过这样子每个微服务都需要加一层代理）。</p><p>链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。</p><h3 id="分析问题-日志分析"><a href="#分析问题-日志分析" class="headerlink" title="分析问题 - 日志分析"></a>分析问题 - 日志分析</h3><p>日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。</p><p>因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：</p><p><img src="https://pic3.zhimg.com/50/v2-b721b26bd974169cffd107ba4eec54f0_hd.jpg?source=1940ef5c"></p><p>小明调查了一下，使用了大名鼎鼎地ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。</p><ul><li>Elasticsearch：搜索引擎，同时也是日志的存储。</li><li>Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。</li><li>Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。</li></ul><p>最后还有一个小问题是如何将日志发送到Logstash。一种方案是在日志输出的时候直接调用Logstash接口将日志发送过去。这样一来又（咦，为啥要用“又”）要修改代码……于是小明选用了另一种方案：日志仍然输出到文件，每个服务里再部署个Agent扫描日志文件然后输出给Logstash。</p><h3 id="网关-权限控制，服务治理"><a href="#网关-权限控制，服务治理" class="headerlink" title="网关 - 权限控制，服务治理"></a>网关 - 权限控制，服务治理</h3><p>拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……</p><p>为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。</p><p>使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。</p><p>由于整个网上超市的服务数量还不算特别多，小明采用的最粗粒度的方案：</p><p><img src="https://pic2.zhimg.com/50/v2-84a6eee84a5dc3f2e97f56b4148bbc66_hd.jpg?source=1940ef5c"></p><h3 id="服务注册于发现-动态扩容"><a href="#服务注册于发现-动态扩容" class="headerlink" title="服务注册于发现 - 动态扩容"></a>服务注册于发现 - 动态扩容</h3><p>前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。</p><p>最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。</p><p>冗余的一个问题是使用几个冗余？这个问题在时间轴上并没有一个切确的答案。根据服务功能、时间段的不同，需要不同数量的实例。比如在平日里，可能4个实例已经够用；而在促销活动时，流量大增，可能需要40个实例。因此冗余数量并不是一个固定的值，而是根据需要实时调整的。</p><p>一般来说新增实例的操作为：</p><ol><li>部署新实例</li><li>将新实例注册到负载均衡或DNS上</li></ol><p>操作只有两步，但如果注册到负载均衡或DNS的操作为人工操作的话，那事情就不简单了。想想新增40个实例后，要手工输入40个IP的感觉……</p><p>解决这个问题的方案是服务自动注册与发现。首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。</p><p><img src="https://pic3.zhimg.com/50/v2-5b0fea85e31caa7b6ed88cb6fbdf5005_hd.jpg?source=1940ef5c"></p><p>服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。</p><p>服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……</p><h3 id="熔断、服务降级、限流"><a href="#熔断、服务降级、限流" class="headerlink" title="熔断、服务降级、限流"></a>熔断、服务降级、限流</h3><h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><p>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p><p><img src="https://picb.zhimg.com/50/v2-1fbc686e2aeef234b9cfe096274e0206_hd.jpg?source=1940ef5c"></p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。</p><p><img src="https://pic1.zhimg.com/50/v2-9a4737be63222fb4928ac6a26b60c92b_hd.jpg?source=1940ef5c"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>微服务架构下，测试分为三个层次：</p><ol><li>端到端测试：覆盖整个系统，一般在用户界面机型测试。</li><li>服务测试：针对服务接口进行测试。</li><li>单元测试：针对代码单元进行测试。</li></ol><p>三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。</p><p><img src="https://pic4.zhimg.com/50/v2-7da95a84f6c0dfd889ceb96acdf98b88_hd.jpg?source=1940ef5c"></p><p>由于端到端测试实施难度较大，一般只对核心功能做端到端测试。一旦端到端测试失败，则需要将其分解到单元测试：则分析失败原因，然后编写单元测试来重现这个问题，这样未来我们便可以更快地捕获同样的错误。</p><p>服务测试的难度在于服务会经常依赖一些其他服务。这个问题可以通过Mock Server解决：</p><p><img src="https://pic1.zhimg.com/50/v2-3f13157528d14462e26d08d1d6be0817_hd.jpg?source=1940ef5c"></p><p>单元测试大家都很熟悉了。我们一般会编写大量的单元测试（包括回归测试）尽量覆盖所有代码。</p><h3 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h3><p>指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。</p><p>使用微服务框架可以实现很多自定义的功能。甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态。</p><p>使用统一的微服务框架有一个比较严重的问题：框架更新成本很高。每次框架升级，都需要所有应用服务配合升级。当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级……因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范。</p><h3 id="另一条路-ServiceMesh"><a href="#另一条路-ServiceMesh" class="headerlink" title="另一条路 - ServiceMesh"></a>另一条路 - ServiceMesh</h3><p>另一种抽象公共代码的方法是直接将这些代码抽象到一个反向代理组件。每个服务都额外部署这个代理组件，所有出站入站的流量都通过该组件进行处理和转发。这个组件被称为Sidecar。</p><blockquote><p>Sidecar不会产生额外网络成本。Sidecar会和微服务节点部署在同一台主机上并且共用相同的虚拟网卡。所以sidecar和微服务节点的通信实际上都只是通过内存拷贝实现的。</p></blockquote><p><img src="https://pic3.zhimg.com/50/v2-567a3bd63e4894d1358c6141fca7ba72_hd.jpg?source=1940ef5c"></p><p> MeshSidecar只负责网络通信。还需要有个组件来统一管理所有sidecar的配置。在Service Mesh中，负责网络通信的部分叫数据平面（data plane），负责配置管理的部分叫控制平面（control plane）。数据平面和控制平面构成了Service Mesh的基本架构。</p><p> <img src="https://pic4.zhimg.com/50/v2-c79af0ff0b1b11ed4586701a3a2e314c_hd.jpg?source=1940ef5c"></p><p> Mesh相比于微服务框架的优点在于它不侵入代码，升级和维护更方便。它经常被诟病的则是性能问题。即使回环网络不会产生实际的网络请求，但仍然有内存拷贝的额外成本。另外有一些集中式的流量处理也会影响性能。结束、也是开始微服务不是架构演变的终点。往细走还有Serverless、FaaS等方向。另一方面也有人在唱合久必分分久必合，重新发现单体架构……</p><p> 不管怎样，微服务架构的改造暂时告一段落了。小明满足地摸了摸日益光滑的脑袋，打算这个周末休息一下约小红喝杯咖啡。</p>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端动态渲染技术实例解析</title>
    <link href="/2020/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    <url>/2020/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="动态渲染库简介"><a href="#动态渲染库简介" class="headerlink" title="动态渲染库简介"></a>动态渲染库简介</h2><p>移动端开发中,对于信息流展示页面,通常对动态性有较高的要求,本地预置模板+接口下发动态组合的方式虽然从某种程度上做到了动态化,但新增样式时依然不可避免需要发版.</p><p>本例中通过自定义页面描述语法,并将其下发至客户端,由客户端实时生成布局并渲染,来实现UI级别的动态化.</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h4 id="将按照Flex规范定义的页面描述文件-转化成对应的原生视图-同时根据其配置信息-从外层数据中查找对应内容进行展示"><a href="#将按照Flex规范定义的页面描述文件-转化成对应的原生视图-同时根据其配置信息-从外层数据中查找对应内容进行展示" class="headerlink" title="将按照Flex规范定义的页面描述文件,转化成对应的原生视图,同时根据其配置信息,从外层数据中查找对应内容进行展示."></a>将按照Flex规范定义的页面描述文件,转化成对应的原生视图,同时根据其配置信息,从外层数据中查找对应内容进行展示.</h4><p><img src="https://i.loli.net/2020/09/02/c9QpVmlKJxuIYjq.png"></p><p><img src="https://i.loli.net/2020/09/02/tZydJPTYxwicmGF.png"></p><h2 id="核心流程详解"><a href="#核心流程详解" class="headerlink" title="核心流程详解"></a>核心流程详解</h2><h3 id="DSL解析"><a href="#DSL解析" class="headerlink" title="DSL解析"></a>DSL解析</h3><p>接口下发的DSL数据示例<br><img src="https://i.loli.net/2020/09/02/tfIUKdhXvmknbyV.png"><br>其中样式,事件,动画的解析,由一个入口XML解析器来分发:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startElement</span><span class="hljs-params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="hljs-keyword">throws</span> SAXException </span>&#123;<br>        <span class="hljs-keyword">if</span> (mInnernalHandler == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (localName) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Action&quot;</span>:<br>                    mInnernalHandler = <span class="hljs-keyword">new</span> ActionXmlHandler();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Animation&quot;</span>:<span class="hljs-comment">//动画还未启用,暂时注释.</span><br><span class="hljs-comment">//                    mInnernalHandler = new AnimationXmlHandler();</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    mInnernalHandler = <span class="hljs-keyword">new</span> DynamicViewXmlHandler();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mInnernalHandler != <span class="hljs-keyword">null</span>) &#123;<br>                mInnernalHandler.startElement(uri, localName, qName, attributes);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mInnernalHandler.startElement(uri, localName, qName, attributes);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/02/iM8jbFhplPLSE47.png"></p><p>入口解析器解析完每一段xml数据,都会返回DslMappingData数据.前端根据数据实际类型进行保存.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">DslMappingData mappingData = XMLParsingMethods.readMixedXmlBySAX(layoutBean.dslXml);<br><span class="hljs-keyword">if</span> (mappingData != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (mappingData <span class="hljs-keyword">instanceof</span> XmlActionEntity) &#123;<br>        mActionPool.addAction((XmlActionEntity) mappingData);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappingData <span class="hljs-keyword">instanceof</span> XmlAnimationEntity) &#123;<br>        mAnimationPool.addAnimation((XmlAnimationEntity) mappingData);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappingData <span class="hljs-keyword">instanceof</span> DynamicViewStyle) &#123;<br>        DynamicViewStyle viewStyle = (DynamicViewStyle) mappingData;<br>        viewStyle.layoutID = layoutBean.layoutID;<br>        viewStyle.ver = layoutBean.ver;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(viewStyle.ver)) &#123;<br>            viewStyle.ver = String.valueOf(System.currentTimeMillis());<br>        &#125;<br>        DynamicViewStyle currentStyle = mLayoutBeanHashMap.get(layoutBean.layoutID);<br>        <span class="hljs-keyword">if</span> (currentStyle == <span class="hljs-keyword">null</span> || currentStyle.ver == <span class="hljs-keyword">null</span>) &#123;<br>            mLayoutBeanHashMap.put(layoutBean.layoutID, viewStyle);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!currentStyle.ver.equals(viewStyle.ver)) &#123;<br>                mLayoutBeanHashMap.put(layoutBean.layoutID, viewStyle);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h3><p>根据DynamicViewStyle中定义的type,生成对应原生控件,并使用对应装饰器对其进行配置.</p><h5 id="DefaultViewGenerator是动态渲染库内部默认实现-提供了对应View的实例化过程"><a href="#DefaultViewGenerator是动态渲染库内部默认实现-提供了对应View的实例化过程" class="headerlink" title="DefaultViewGenerator是动态渲染库内部默认实现,提供了对应View的实例化过程:"></a>DefaultViewGenerator是动态渲染库内部默认实现,提供了对应View的实例化过程:</h5><h4 id="1-根据对应type-生成原生控件和其对应装饰器"><a href="#1-根据对应type-生成原生控件和其对应装饰器" class="headerlink" title="1. 根据对应type,生成原生控件和其对应装饰器."></a>1. 根据对应type,生成原生控件和其对应装饰器.</h4><h5 id="生成原生控件"><a href="#生成原生控件" class="headerlink" title="生成原生控件"></a>生成原生控件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> DynamicViewDecorator <span class="hljs-title">makeSingleView</span><span class="hljs-params">(Activity activity, DynamicViewStyle style)</span> </span>&#123;<br>        DynamicViewDecorator viewHolder = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (style.type != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (style.type) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;View&quot;</span>:<br>                    viewHolder = <span class="hljs-keyword">new</span> YogaLayoutDecorator(<span class="hljs-keyword">new</span> CustomYogaLayout(activity));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;CardView&quot;</span>:<br>                    viewHolder = <span class="hljs-keyword">new</span> CardViewDecorator(<span class="hljs-keyword">new</span> MgCardView(activity));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ListView&quot;</span>:<br>                    viewHolder = <span class="hljs-keyword">new</span> ListViewDecorator(<span class="hljs-keyword">new</span> DynamicListView(activity));<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (viewHolder == <span class="hljs-keyword">null</span>) &#123;<br>                View view = mExtendViewCreater.makeView(activity, style.type);<br>                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                    viewHolder = <span class="hljs-keyword">new</span> ExtendViewDecorator(view);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> viewHolder;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="根据控件类型-使用不同的装饰器进行属性配置"><a href="#根据控件类型-使用不同的装饰器进行属性配置" class="headerlink" title="根据控件类型,使用不同的装饰器进行属性配置"></a>根据控件类型,使用不同的装饰器进行属性配置</h5><p>此处装饰器!=装饰者模式,仅是用于对不同类型的控件,进行特有的动态属性设置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 作者：徐斌 &lt;br&gt;</span><br><span class="hljs-comment"> * 日期：2020 08/03 10:09 &lt;br&gt;</span><br><span class="hljs-comment"> * 说明：动态渲染控件配置接口,定义了目前动态渲染支持的一些属性.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DslDecorator</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析配置的Layout属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean DynamicViewStyle中的layout</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parent 父容器.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parseLayout</span><span class="hljs-params">(StyleLayout bean, <span class="hljs-meta">@Nullable</span> ViewGroup parent)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析配置的Attr属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> styleAttr DynamicViewStyle中的attr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> acitonObject DynamicViewStyle中的action</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> actionPool 外部的Action池子.定义了各种事件.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parseAttr</span><span class="hljs-params">(Map&lt;String, String&gt; styleAttr, ActionEntity acitonObject, ActionPool actionPool)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析配置的动画属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animationEntity DynamicViewStyle中的animation部分</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animationPool 外部的Animation池子.定义了各种动画.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parseAnimation</span><span class="hljs-params">(AnimationEntity animationEntity, AnimationPool animationPool)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-解析DynamicViewStyle中的layout配置-并应用-以通用的DynamicViewDecorator为例"><a href="#2-解析DynamicViewStyle中的layout配置-并应用-以通用的DynamicViewDecorator为例" class="headerlink" title="2. 解析DynamicViewStyle中的layout配置,并应用(以通用的DynamicViewDecorator为例)."></a>2. 解析DynamicViewStyle中的layout配置,并应用(以通用的DynamicViewDecorator为例).</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseLayout</span><span class="hljs-params">(StyleLayout bean, <span class="hljs-meta">@Nullable</span> ViewGroup parent)</span> </span>&#123;<br>    YogaNode yogaNode = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> YogaLayout) &#123;<br>        yogaNode = ((YogaLayout) parent).getYogaNodeForView(itemView);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (yogaNode != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (bean.alignSelf != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (bean.alignSelf) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;flex-end&quot;</span>:<br>                    yogaNode.setAlignSelf(YogaAlign.FLEX_END);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;center&quot;</span>:<br>                    yogaNode.setAlignSelf(YogaAlign.CENTER);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;space-between&quot;</span>:<br>                    yogaNode.setAlignSelf(YogaAlign.SPACE_BETWEEN);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;space-around&quot;</span>:<br>                    yogaNode.setAlignSelf(YogaAlign.SPACE_AROUND);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    yogaNode.setAlignSelf(YogaAlign.FLEX_START);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            yogaNode.setAlignSelf(YogaAlign.AUTO);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-解析DynamicViewStyle中的attr配置-并应用-以通用的DynamicViewDecorator为例"><a href="#3-解析DynamicViewStyle中的attr配置-并应用-以通用的DynamicViewDecorator为例" class="headerlink" title="3. 解析DynamicViewStyle中的attr配置,并应用(以通用的DynamicViewDecorator为例)."></a>3. 解析DynamicViewStyle中的attr配置,并应用(以通用的DynamicViewDecorator为例).</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> DynamicValueBinder&lt;T&gt; <span class="hljs-title">onParseAttr</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Map&lt;String, String&gt; styleAttr, <span class="hljs-meta">@Nullable</span> ActionEntity acitonObject, ActionPool actionPool)</span> </span>&#123;<br>    ValueStore valueStore;<br>    DynamicValueBinder&lt;T&gt; binder = createDynamicValueBinder();<br>    <span class="hljs-keyword">if</span> (styleAttr != <span class="hljs-keyword">null</span>) &#123;<br>        String alphaStr = styleAttr.get(<span class="hljs-string">&quot;alpha&quot;</span>);<br>        <span class="hljs-keyword">if</span> (alphaStr != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">float</span> alphaNum = DynamicUtil.stringToFloat(alphaStr);<br>            <span class="hljs-keyword">if</span> (alphaNum != <span class="hljs-number">0</span>) &#123;<br>                itemView.setAlpha(alphaNum);<br>            &#125;<br>        &#125;<br>        String visibleStr = styleAttr.get(<span class="hljs-string">&quot;visible&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(visibleStr)) &#123;<br>            valueStore = <span class="hljs-keyword">new</span> ValueStore(visibleStr);<br>            binder.addDataPath(<span class="hljs-string">&quot;visible&quot;</span>, valueStore);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> binder;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-为需要动态设置渲染内容的View配置id-用于外部查找"><a href="#4-为需要动态设置渲染内容的View配置id-用于外部查找" class="headerlink" title="4. 为需要动态设置渲染内容的View配置id,用于外部查找."></a>4. 为需要动态设置渲染内容的View配置id,用于外部查找.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第四步,设置attr属性,影响该控件显示的内容.</span><br><span class="hljs-comment">// 如果是普通控件,按照是否有动态数据和是否有事件来决定生成id并加入列表</span><br><span class="hljs-comment">// 否则直接给生成一个id,然后加入列表</span><br><span class="hljs-keyword">if</span> (viewHolder <span class="hljs-keyword">instanceof</span> ExtendViewDecorator) &#123;<br>    <span class="hljs-keyword">int</span> id = countHelper.getIdAndInCrease();<br>    itemView.setId(id);<br>    <span class="hljs-keyword">if</span> (bindableViewIds != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//bindableViewIds是对应某个layout样式的,这里做个判空,防止重复添加.</span><br>        bindableViewIds.add(id);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    viewHolder.parseAttr(style.attr, style.action, mActionPool);<br>    <span class="hljs-comment">//如果该控件有需要动态设置的属性.设置id,并把id放入公共的id列表中.</span><br>    <span class="hljs-keyword">if</span> (viewHolder.needDynamicBind) &#123;<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (itemView <span class="hljs-keyword">instanceof</span> PlayerView) &#123;<br>            id = R.id.dsl_tag_playerview;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (itemView <span class="hljs-keyword">instanceof</span> BackgroundView) &#123;<br>            id = R.id.dsl_tag_backgroundview;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            id = countHelper.getIdAndInCrease();<br>        &#125;<br>        itemView.setId(id);<br>        <span class="hljs-keyword">if</span> (bindableViewIds != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//bindableViewIds是对应某个layout样式的,这里做个判空,防止重复添加.</span><br>            bindableViewIds.add(id);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-为列表型View设置item样式"><a href="#5-为列表型View设置item样式" class="headerlink" title="5. 为列表型View设置item样式."></a>5. 为列表型View设置item样式.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (style.item != <span class="hljs-keyword">null</span> &amp;&amp; itemView <span class="hljs-keyword">instanceof</span> DslListInterface) &#123;<br>    ((DslListInterface) itemView).setDynamicStyle(style.item, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-重复1-5-对其child进行实例化-并构建层次结构"><a href="#6-重复1-5-对其child进行实例化-并构建层次结构" class="headerlink" title="6. 重复1~5,对其child进行实例化,并构建层次结构."></a>6. 重复1~5,对其child进行实例化,并构建层次结构.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第七步,如果这是个容器.遍历一下.添加child.</span><br><span class="hljs-keyword">if</span> (itemView <span class="hljs-keyword">instanceof</span> ViewGroup &amp;&amp; style.children != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (DynamicViewStyle childBean : style.children) &#123;<br>        makeCurrentView(activity, (ViewGroup) itemView, childBean, bindableViewIds, countHelper, connectionHelper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-完成View-View间的绑定关系-目前用于Banner-Indicator"><a href="#7-完成View-View间的绑定关系-目前用于Banner-Indicator" class="headerlink" title="7. 完成View-View间的绑定关系(目前用于Banner-Indicator)."></a>7. 完成View-View间的绑定关系(目前用于Banner-Indicator).</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * view创建完了.来做个绑定吧..可能内部存在啥联动之类的.比如banner和指示器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">creatConections</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mConnectionAbleArrayList.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (ConnectionAble connectionAble : mConnectionAbleArrayList) &#123;<br>            <span class="hljs-keyword">for</span> (ConnectionAble connectionAble2 : mConnectionAbleArrayList) &#123;<br>                <span class="hljs-keyword">if</span> (connectionAble != connectionAble2) &#123;<br>                    connectionAble.onConection(connectionAble2);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    mConnectionAbleArrayList.clear();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对于动态渲染库不支持的type-会在第一步中调用设置的mExtendViewCreater来进行控件生成过程"><a href="#对于动态渲染库不支持的type-会在第一步中调用设置的mExtendViewCreater来进行控件生成过程" class="headerlink" title="对于动态渲染库不支持的type,会在第一步中调用设置的mExtendViewCreater来进行控件生成过程."></a>对于动态渲染库不支持的type,会在第一步中调用设置的mExtendViewCreater来进行控件生成过程.</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (viewHolder == <span class="hljs-keyword">null</span>) &#123;<br>    View view = mExtendViewCreater.generateView(activity, style);<br>    <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>        viewHolder = <span class="hljs-keyword">new</span> ExtendViewDecorator(view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p><strong>理论上所有配置在attr中的属性,都支持通过相对路径从数据实体中取值,并设置.</strong></p><blockquote><p>例如attr中配置text:~title,则意味着该控件将外部数据实体看做JsonObject,取其title字段当做文本内容.</p></blockquote><p>在样式描述体中定义控件的某个属性和其取值对应路径,待外层拿到数据实体后,进行实时解析并设置给控件的过程,即<strong>动态绑定</strong>.</p><p>动态绑定定义在ValueBinder接口中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataBinder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给定view和数据源,尝试用内部的datePathMap进行解析,然后设置给view</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> view 当前view</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据源</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> listIndex 在列表中的index</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rendWithData</span><span class="hljs-params">(T view, JsonObject data, CommBridge commBridge,<span class="hljs-keyword">int</span> listIndex)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其主要有两类实现:</p><ul><li>DynamicValueBinder:动态渲染库内部实现,具备保存属性和相对路径映射的能力.</li><li>外部业务层实现类:对应原生控件,根据预置的属性和解析策略,自行实现渲染方法.</li></ul><p>DynamicValueBinder结构图</p><p><img src="https://i.loli.net/2020/09/02/6XfwVW3pZy1QtTo.png"></p><h3 id="逻辑计算"><a href="#逻辑计算" class="headerlink" title="逻辑计算"></a>逻辑计算</h3><p>属性对应的值以^开头时,意味着不仅需要动态取值,还要进行逻辑运算.</p><p>例如visible:^feedBack and fdTags.count!=0代表当外层数据feedBack值不为空,且fdTags数据对应的列表长度不为0时,visible值为1.</p><p>动态渲染库中集成了简单的逻辑处理流程,目前支持and,or,==,!=,三目运算.</p><p><img src="https://i.loli.net/2020/09/02/YqdFsgxZbnzfW2t.png"></p><p>采用类似二叉树概念,将逻辑语句拆解,转化成多个可计算的最小单元,从末端开始计算,最终得到整体计算结果.</p><p><img src="https://i.loli.net/2020/09/02/ZNVxAjgpcDMfI2a.png"></p><h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>当前事件主要有3种</p><ul><li>曝光事件.RenderAction.在渲染时产生.对应rendWithData调用时.</li><li>点击事件.ClickAction.点击时产生.</li><li>列表滑动事件.ChildScrollAction.列表控件的item滑动时产生.</li></ul><p><img src="https://i.loli.net/2020/09/02/FRSOC9mfiQGz537.png"></p><p>事件通过rendWithData(T view, JsonObject data, CommBridge commBridge,int listIndex)中的CommBridge对外传递.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UI级别的动态化由于完全采用平台api实现.在放弃部分灵活性的同时,保证其性能和兼容性,是当前移动端不可或缺的技术之一,其设计思路对于设计真正的跨平台框架也有所帮助.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AS打开Flutter项目,原生android工程标红的问题</title>
    <link href="/2020/08/14/AS%E6%89%93%E5%BC%80Flutter%E9%A1%B9%E7%9B%AE-%E5%8E%9F%E7%94%9Fandroid%E5%B7%A5%E7%A8%8B%E6%A0%87%E7%BA%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/14/AS%E6%89%93%E5%BC%80Flutter%E9%A1%B9%E7%9B%AE-%E5%8E%9F%E7%94%9Fandroid%E5%B7%A5%E7%A8%8B%E6%A0%87%E7%BA%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>现象:</strong><br>使用AS新建或者打开一个Flutter项目后,原生android工程部分,MainActivity中FlutterActivity标红,提示找不到FlutterActivity类.<br><img src="https://raw.githubusercontent.com/icemanstudy/ImageStore/master/20200808171746.png"></p><h4 id="实际上-关于在原生工程中进行Flutter关联开发所需要的所有类-都引用失败了"><a href="#实际上-关于在原生工程中进行Flutter关联开发所需要的所有类-都引用失败了" class="headerlink" title="实际上,关于在原生工程中进行Flutter关联开发所需要的所有类,都引用失败了."></a>实际上,关于在原生工程中进行Flutter关联开发所需要的所有类,都引用失败了.</h4><p>虽然进行Flutter开发没有问题,main.dart中的代码自动完成也运行正常.但是如果需要同时开发dart和原生,就很不方便了,原生工程里面一片红,代码自动完成完全失效了.为此,特地探究一下报错的原因.</p><p>网上的做法千篇一律:</p><blockquote><p>删掉android和ios两个目录,然后用”flutter create . “命令重新创建两个原生工程.</p></blockquote><blockquote><p>PS:flutter create -a java .可以创建使用java语言的andorid工程(默认是koltin).</p></blockquote><h3 id="然而-并没有什么卵用-AS-3-6-3-4-0-1-flutter-1-20-1-stable"><a href="#然而-并没有什么卵用-AS-3-6-3-4-0-1-flutter-1-20-1-stable" class="headerlink" title="然而.并没有什么卵用.(AS 3.6.3/4.0.1,flutter 1.20.1 stable)"></a>然而.并没有什么卵用.(AS 3.6.3/4.0.1,flutter 1.20.1 stable)</h3><p>仔细观察项目,发现一点猫腻.<br><img src="https://raw.githubusercontent.com/icemanstudy/ImageStore/master/20200814173629.png"></p><p>为什么这个app<strong>文件夹上没有图标</strong>呢?</p><p>没有图标就意味着没有识别出这是一个AS支持的工程,进而意味着不会解析下面的build.gradle,然后就不会加载各种依赖.</p><p><strong>总而言之AS认不出来,那么这就是个普通文件夹.还不如用文本编辑器打开呢,好歹没有红色报错.</strong></p><p>AS打开普通的andorid工程,是靠解析对应文件夹下面的build.gradle和setttings.gradle.然而这个app工程并不在当前根目录下,其父目录android本该作为根目录由AS打开,实际上由于还有flutter,ios相关文件夹,当前AS打开的是其父目录flutterstudy.</p><p>那么直接用AS打开android文件夹试试?</p><p>编译,运行没有问题.done~</p><p><img src="https://raw.githubusercontent.com/icemanstudy/ImageStore/master/20200808180444.png"></p><p>顺便瞄了眼这个FlutterActivity所在的包,为啥就依赖不到呢.</p><p><img src="https://raw.githubusercontent.com/icemanstudy/ImageStore/master/20200808180513.png"></p><p>看来是一个叫flutter_embedding_debug:1.0.0的依赖.用于原生项目可以加载dart产物.然而由于上述的原因,根本没有加载,导致原生工程啥也做不了.</p><p>弄来弄去,只是明白了原因,但问题并没有解决.退而求其次:  </p><ul><li>做flutter开发时,打开flutter工程.  </li><li>做原生开发时,打开内部的原生工程.</li></ul><p>等待flutter插件的更新吧~</p>]]></content>
    
    
    <categories>
      
      <category>跨平台</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter动画-Animation</title>
    <link href="/2020/08/08/Flutter%E5%8A%A8%E7%94%BB-Animation/"/>
    <url>/2020/08/08/Flutter%E5%8A%A8%E7%94%BB-Animation/</url>
    
    <content type="html"><![CDATA[<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h5 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h5><p>动画类,用于获取动画当前的值和状态.</p><h5 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h5><p>定义动画值的范围.其默认单位是double,同时也有Tween的不同子类,用于定义不同的动画值类型(例如颜色,对齐方式).  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">animation1 = <span class="hljs-keyword">new</span> Tween&lt;double&gt;(<span class="hljs-keyword">begin</span>: <span class="hljs-number">100</span>, <span class="hljs-keyword">end</span>: <span class="hljs-number">300</span>);<br>animation2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ColorTween(<span class="hljs-params">begin</span>: Colors.<span class="hljs-params">transparent</span>, <span class="hljs-params">end</span>: Colors.<span class="hljs-params">black54</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h5><p>定义Tween的变化速度.类似Interpolator.</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@override</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">transform</span><span class="hljs-params">(<span class="hljs-keyword">double</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0.0</span> || t == <span class="hljs-number">1.0</span>) &#123;<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">transform</span><span class="hljs-params">(t)</span></span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h5><p>继承自Animation的特殊动画,有两个特征:</p><ul><li>内部包含一个从0~1的动画取值范围.</li><li>具备控制动画的方法,例如forward,reverse方法和指定动画时长.  </li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">controller = <span class="hljs-keyword">new</span> AnimationController(<span class="hljs-attr">duration:</span> Duration(<span class="hljs-attr">milliseconds:</span> <span class="hljs-number">2000</span>), <span class="hljs-attr">vsync:</span> <span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>vsync参数:通常是混入SingleTickerProviderStateMixin类的某个widget,当该widget不显示时,动画暂停,widget显示时,动画恢复执行,用于避免动画相关UI不在屏幕时消耗资源.</p><h5 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h5><p>另一个继承自Animation的特殊动画,比较方便的指定Tween的变化速度.  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">curvedAnimation = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CurvedAnimation(<span class="hljs-params">parent</span>: <span class="hljs-params">controller</span>,<span class="hljs-params">curve</span>: Curves.<span class="hljs-params">easeInOutBack</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="Flutter中的动画"><a href="#Flutter中的动画" class="headerlink" title="Flutter中的动画"></a>Flutter中的动画</h3><p>动画本质上是控件的某个样式属性,按照一定的规则进行变化.<br>Flutter中将该属性的取值,变化范围和变化速度分开定义,最终组合成动画.</p><h3 id="动画实现方式"><a href="#动画实现方式" class="headerlink" title="动画实现方式"></a>动画实现方式</h3><h4 id="基本实现方式"><a href="#基本实现方式" class="headerlink" title="基本实现方式"></a>基本实现方式</h4><p>步骤:</p><ol><li>构建Tween类指定动画取值范围(若类似透明度这种,从0~1,可跳过该步骤)</li><li>使用CurvedAnimation指定变化曲线(若为线性变化,可跳过该步骤)</li><li>使用AnimationController启动动画</li><li>实时获取当前动画值</li><li>在控件属性上应用</li></ol><p>获取动画状态和进度的方式  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">animation<br>      ..add<span class="hljs-constructor">StatusListener((<span class="hljs-params">status</span>)</span> &#123;<br>        print(<span class="hljs-string">&quot;animation当前状态:&quot;</span> + animation.value.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>      &#125;)<br>      ..add<span class="hljs-constructor">Listener(()</span> &#123;<br>        print(<span class="hljs-string">&quot;animation当前值:&quot;</span> + animation.value.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>      &#125;);<br></code></pre></td></tr></table></figure><p>在创建Widget时,使用动画当前值作为属性值.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">body:</span> Center(<br><span class="hljs-symbol">  child:</span> Image(<br><span class="hljs-symbol">    image:</span> AssetImage(<span class="hljs-string">&quot;images/pig.png&quot;</span>),<br><span class="hljs-symbol">    width:</span> animation.value,<br><span class="hljs-symbol">    height:</span> animation.value,<br><span class="hljs-symbol">    fit:</span> BoxFit.fill,<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>启动动画,在动画值发生变化时,调用StatefulWidget对应State的setState方法,触发Widget的重新build.使其刷新样式.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">controller.forward<span class="hljs-literal">()</span>;<br>animation<br>  ..add<span class="hljs-constructor">Listener(()</span> &#123;<br>    set<span class="hljs-constructor">State(()</span> &#123;<br>      print(<span class="hljs-string">&quot;animation当前值:&quot;</span> + animation.value.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>    &#125;);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>注意:<br>在控件被移除时,将动画释放,防止内存泄漏.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@override</span><br><span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">dispose</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">super</span>.dispose();<br>  controller.dispose();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用AnimatedWidget控件实现"><a href="#使用AnimatedWidget控件实现" class="headerlink" title="使用AnimatedWidget控件实现"></a>使用AnimatedWidget控件实现</h4><p>系统提供继承自StatefullWidget的AnimatedWidget控件来自动完成addStateListener并在值变化时调用setState的方法.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatedImage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnimatedWidget</span> </span>&#123;<br>  <span class="hljs-type">AnimatedImage</span>(&#123;<span class="hljs-type">Key</span> key, <span class="hljs-type">Animation</span>&lt;double&gt; animation&#125;)<br>      : <span class="hljs-keyword">super</span>(key: key, listenable: animation);<br><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Animation</span>&lt;double&gt; animation = listenable;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Center</span>(<br>      child: <span class="hljs-type">Image</span>(<br>          image: <span class="hljs-type">AssetImage</span>(<span class="hljs-string">&quot;images/pig.png&quot;</span>),<br>          width: animation.value,<br>          height: animation.value,<br>          fit: <span class="hljs-type">BoxFit</span>.fill,<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构建时传入动画变量,并在内部build方法中使用动画值来创建控件.这样动画在执行时会自动调用setState进而触发build方法重新构建控件.</p><h4 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a>职责分离</h4><p>在上述例子中,动画直接植入到控件的build方法中,其child的生成关联在一起.然而实际使用中控件自身的动画应该与其child的展示<strong>解耦</strong>.该控件应该可以在<strong>接收任何child</strong>的同时,正常展示指定动画. </p><p>职责分离:</p><ul><li>显示图片</li><li>指定Animation对象</li><li>渲染过渡效果</li></ul><p>AnimatedBuilder继承自AnimatedWidget,在其内部执行addStateListener和setState操作的同时,使用build参数将child做透传,使动画应用于child的构建完全隔离.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageTransition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-type">ImageTransition</span>(&#123;<span class="hljs-keyword">this</span>.child, <span class="hljs-keyword">this</span>.animation&#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Widget</span> child;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">Animation</span>&lt;double&gt; animation;<br><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Center</span>(<br>      child: <span class="hljs-keyword">new</span> <span class="hljs-type">AnimatedBuilder</span>(<br>          animation: animation,<br>          builder: (<span class="hljs-type">BuildContext</span> context, <span class="hljs-type">Widget</span> child) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Container</span>(<br>                height: animation.value, width: animation.value, child: child);<br>          &#125;,<br>          child: child),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="系统预置的动画控件"><a href="#系统预置的动画控件" class="headerlink" title="系统预置的动画控件"></a>系统预置的动画控件</h4><p>针对常用动画,系统提供了一系列继承自AnimatedWidget的控件来方便开发者实现.例如ScaleTransition,FadeTransition.</p><p>例如缩放动画,只用ScaleTransition包装,并指定动画值来源即可.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">body:</span> Center(<br><span class="hljs-symbol">    child:</span> ScaleTransition(<br><span class="hljs-symbol">        scale:</span> animation,<br><span class="hljs-symbol">        child:</span> Image(<br><span class="hljs-symbol">          image:</span> AssetImage(<span class="hljs-string">&quot;images/pig.png&quot;</span>),<br>        ))),<br></code></pre></td></tr></table></figure><p>透明度动画同理:  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">body:</span> Center(<br><span class="hljs-symbol">    child:</span> FadeTransition(<br><span class="hljs-symbol">        opacity:</span> animation,<br><span class="hljs-symbol">        child:</span> Image(<br><span class="hljs-symbol">          image:</span> AssetImage(<span class="hljs-string">&quot;images/pig.png&quot;</span>),<br>        ))),<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>跨平台</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>轻量级的跨平台UI动态化方案-yoga</title>
    <link href="/2020/01/06/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0UI%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88-yoga/"/>
    <url>/2020/01/06/%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0UI%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88-yoga/</url>
    
    <content type="html"><![CDATA[<p> 时间已到2020年,作为有google官方研发,闲鱼背书的方案,Flutter是越来越火了.</p><p> 然而考虑到apple store谜一样的审核策略,有部分比较稳妥的企业,并不倾向于使用这种完全从底层实现的跨平台方案.</p><p> 那么,有没有比较轻量级的跨平台方案,只将描述语言统一,由各自客户端解析成原生样式展示呢.这便是facebook推出的UI动态化方案–<strong>yoga</strong>.</p><h3 id="yoga简介"><a href="#yoga简介" class="headerlink" title="yoga简介"></a>yoga简介</h3><p>yoga的官方网站:<a href="https://yogalayout.com/">https://yogalayout.com/</a></p><p>github地址:<a href="https://github.com/facebook/yoga">https://github.com/facebook/yoga</a></p><p>yogalayout支持的属性与css中的弹性盒子样式对应,<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout</a></p><h3 id="现有的yoga使用示例"><a href="#现有的yoga使用示例" class="headerlink" title="现有的yoga使用示例"></a>现有的yoga使用示例</h3><h4 id="某不知名github主的demo"><a href="#某不知名github主的demo" class="headerlink" title="某不知名github主的demo"></a>某不知名github主的demo</h4><p><a href="https://github.com/koudle/AndYogaSample">https://github.com/koudle/AndYogaSample</a></p><p>clone下来试用之,发现其只是非常粗浅的使用:</p><p><strong>每一个YogaNode都要指定宽高,指定放置方式,最后一起计算得到最终的每个node的坐标,还不支持dp…</strong></p><h4 id="QQ音乐团队发布的yoga使用示例"><a href="#QQ音乐团队发布的yoga使用示例" class="headerlink" title="QQ音乐团队发布的yoga使用示例"></a>QQ音乐团队发布的yoga使用示例</h4><p><a href="https://cloud.tencent.com/developer/article/1006148">https://cloud.tencent.com/developer/article/1006148</a></p><p>其中YogaNode的创建和布局方式来源于上一个,但是最终居然还是创建出原生控件然后逐个设置X,Y.这有什么意义…</p><p><strong>我都知道了每个YogaNode的尺寸,位置,还需要用yoga?直接给控件设置上去不好么???</strong></p><p>不客气的说,前面两个都是屎.</p><h4 id="yoga官方的demo"><a href="#yoga官方的demo" class="headerlink" title="yoga官方的demo"></a>yoga官方的demo</h4><p><a href="https://github.com/facebook/yoga/tree/master/android">https://github.com/facebook/yoga/tree/master/android</a></p><p>原来还有针对android的自定义控件YogaLayout.类似google的FlexBoxLayout,通过自定义控件来支持各种flex属性,看起来好像是那么回事.</p><p>不知道为什么网上为数不多的介绍都没有用到官方demo,大概是官方仓库的编译方式不是gradle吧.</p><p>然而改成gradle编译通过后,发现demo中并没有看到有<strong>动态</strong>的能力.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br>&lt;YogaLayout<br>    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>    xmlns:yoga=&quot;http://schemas.android.com/apk/res-auto&quot;<br>    android:layout_width=&quot;match_parent&quot;<br>    android:layout_height=&quot;60dp&quot;<br>    yoga:yg_flexDirection=&quot;row&quot;<br>    yoga:yg_alignItems=&quot;center&quot;<br>    &gt;<br>  &lt;View<br>      android:layout_width=&quot;50dp&quot;<br>      android:layout_height=&quot;50dp&quot;<br>      android:background=&quot;@color/yoga_blue&quot;<br>      yoga:yg_flex=&quot;0&quot;<br>      yoga:yg_marginAll=&quot;5dp&quot;<br>      /&gt;<br>  &lt;TextView<br>      android:layout_width=&quot;wrap_content&quot;<br>      android:layout_height=&quot;wrap_content&quot;<br>      android:text=&quot;@string/child_1_text&quot;<br>      yoga:yg_flex=&quot;0&quot;<br>      /&gt;<br>  &lt;TextView<br>      android:layout_width=&quot;wrap_content&quot;<br>      android:layout_height=&quot;wrap_content&quot;<br>      android:text=&quot;@string/child_2_text&quot;<br>      yoga:yg_flex=&quot;1&quot;<br>      yoga:yg_marginHorizontal=&quot;5dp&quot;<br>  /&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">YogaLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>真正的实际使用中,不可能直接下发xml到客户端,所以还是需要通过源码看看有没有动态创建YogaLayout的方法.</p><h3 id="干货-全网独家-使用YogaLayout做真正的动态化"><a href="#干货-全网独家-使用YogaLayout做真正的动态化" class="headerlink" title="干货!全网独家,使用YogaLayout做真正的动态化."></a>干货!全网独家,使用YogaLayout做真正的动态化.</h3><h4 id="YogaLayout的动态创建和属性配置"><a href="#YogaLayout的动态创建和属性配置" class="headerlink" title="YogaLayout的动态创建和属性配置"></a>YogaLayout的动态创建和属性配置</h4><p>Yoga其实是通过每个控件绑定的YogaNode来计算和保存位置信息,YogaLayout的node会在构造方法中自动创建,其动态创建和配置代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建YogaLayout</span><br>YogaLayout yogaLayout = <span class="hljs-keyword">new</span> YogaLayout(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//拿到内部Node进行容器配置</span><br>YogaNode yogaNode = yogaLayout.getYogaNode();<br>yogaNode.setFlexDirection(YogaFlexDirection.ROW);<br><span class="hljs-comment">//将容器添加到现有的父组件</span><br>rootLayout.addView(yogaLayout,<span class="hljs-keyword">new</span> FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));<br></code></pre></td></tr></table></figure><h4 id="Child的动态创建和属性配置"><a href="#Child的动态创建和属性配置" class="headerlink" title="Child的动态创建和属性配置"></a>Child的动态创建和属性配置</h4><p>Child也分YogaLayout和普通控件如TextView之类.但是观察源码得知:在加入YogaLayout的时候,会自动为其创建YogaNode.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> YogaLayout) &#123;<br>  childNode = ((YogaLayout) child).getYogaNode();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span>(mYogaNodes.containsKey(child)) &#123;<br>    childNode = mYogaNodes.get(child);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    childNode = YogaNode.create();<br>  &#125;<br><br>  childNode.setData(child);<br>  childNode.setMeasureFunction(<span class="hljs-keyword">new</span> ViewMeasureFunction());<br>&#125;<br></code></pre></td></tr></table></figure><p>因此child的动态配置代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建基本控件</span><br>textView1 = <span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">this</span>);<br>textView1.setText(<span class="hljs-string">&quot;动态文案&quot;</span>);<br>textView1.setGravity(Gravity.CENTER);<br>textView1.setTextColor(Color.WHITE);<br>textView1.setBackgroundColor(Color.RED);<br><span class="hljs-comment">//将控件添加到YogaLayout中</span><br>yogaLayout.addView(textView1, -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> YogaLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,<br>        ViewGroup.LayoutParams.WRAP_CONTENT));<br><span class="hljs-comment">//得到控件对应的YogaNode</span><br>textNode1 = yogaLayout.getYogaNodeForView(textView1);<br><span class="hljs-comment">//设置Flex属性</span><br>textNode1.setFlex(<span class="hljs-number">1</span>);<br>textNode1.setAlignSelf(YogaAlign.CENTER);<br></code></pre></td></tr></table></figure><p>这里和传统的ViewGroup+LayoutParams稍有不同的是,<strong>YogaNode必须在被添加进父容器后再从父容器获取</strong>.<br>当然YogaLayout也提供了addView(View child, YogaNode node)这样的方法,可以用类似传统方式把child和node一起加进去,但是需要对YogaNode做一些本在addView(View child, int index, ViewGroup.LayoutParams params)中自动完成的操作,比较麻烦,这里就不赘述了.</p><h4 id="如何在渲染完成之后-动态修改控件的布局"><a href="#如何在渲染完成之后-动态修改控件的布局" class="headerlink" title="如何在渲染完成之后,动态修改控件的布局"></a>如何在渲染完成之后,动态修改控件的布局</h4><p>看完前面的,已经可以完成静态渲染了,然后在原生开发中,不可避免的要将其用于列表中,总所周知,列表的item是复用的,那么YogaLayout能否二次修改其内部布局呢?</p><p>这部分研究花了较长时间,甚至在尝试对交叉轴方向容器大小进行动态修改时一度认为YogaLayout存在问题.</p><p>直接上结论吧:</p><h5 id="对于YogaLayout内部元素的尺寸进行二次修改-使用YogaLayout-invalidate-View-view-方法"><a href="#对于YogaLayout内部元素的尺寸进行二次修改-使用YogaLayout-invalidate-View-view-方法" class="headerlink" title="对于YogaLayout内部元素的尺寸进行二次修改.使用YogaLayout.invalidate(View view)方法."></a>对于YogaLayout内部元素的尺寸进行二次修改.使用YogaLayout.invalidate(View view)方法.</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">findViewById(R.id.button1).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        textView1.setText(<span class="hljs-string">&quot;文案动态修改,加长&quot;</span>);<br>        yogaLayout.invalidate(textView1);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>哪个元素的内容发生了变化,就调用其parent的invalidate方法.由于其内部实际上是将其node标记为dirty,所以并不用担心性能问题.</p><h5 id="YogaLayout内部元素变更后-对YogaLayout自身的尺寸进行自动适应-需要将YogaLayout的宽高设置为Float-NaN"><a href="#YogaLayout内部元素变更后-对YogaLayout自身的尺寸进行自动适应-需要将YogaLayout的宽高设置为Float-NaN" class="headerlink" title="YogaLayout内部元素变更后,对YogaLayout自身的尺寸进行自动适应.需要将YogaLayout的宽高设置为Float.NaN."></a>YogaLayout内部元素变更后,对YogaLayout自身的尺寸进行自动适应.需要将YogaLayout的宽高设置为Float.NaN.</h5><p>举个例子:<br>YogaLayout内部的TextView文字大小发生了变化.导致YogaLayout的高度也要跟着变大.此时使用YogaLayout.invalidate(View view)方法仅能将textview的尺寸变大,yogaLayout自身并不会撑高.</p><p>尝试了包括invalidate,requestLayout,calculateLayout等无数方法,都无法改变最外层YogaLayout的高度.<br>最后发现:将YogaLayout高度设置为Float.NaN即可让其重新计算…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">findViewById(R.id.button1).setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        textView1.setTextSize(<span class="hljs-number">30</span>);<br>        yogaLayout.invalidate(textView1);<br>        yogaLayout.getYogaNode().setHeight(Float.NaN);<br>        yogaLayout.getYogaNode().setWidth(Float.NaN);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>—–<br>自此,已经可以完成基于YogaLayout的动态渲染.然而这只是UI部分,完整的渲染还需要进行数据绑定.这一部分涉及UI描述文件结构的定义,通过data相对路径+view绑定binder来实现.因篇幅过长,就不介绍了.</p>]]></content>
    
    
    <categories>
      
      <category>跨平台</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android上实现卡片阴影的正确姿势</title>
    <link href="/2020/01/03/android%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E9%98%B4%E5%BD%B1%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <url>/2020/01/03/android%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E9%98%B4%E5%BD%B1%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<p>列表中的卡片式布局如今已经司空见惯了.通常来说卡片式布局有以下特征:</p><ul><li>有圆角</li><li>边距加大</li><li>边框有阴影</li></ul><p>圆角可以用<strong>GradientDrawable</strong>的Corner相关api实现.<br>边距什么的太简单就不说了.<br>最麻烦的要数阴影.先说说市面上常用的方式存在的问题:</p><ul><li><p>使用<strong>CardView</strong>包装.<br>  1.仅支持5.0及以上.<br>  2.不支持修改阴影颜色,在暗夜模式下无法显示.</p></li><li><p>使用<strong>View.setElevation</strong>方法.同CardView.</p></li><li><p>使用自定义shape+.9图片.<br>  1.后期修改麻烦.<br>  2..9图片和shape组合会有莫名其妙的layout问题.<br>  3..9图片的存在会影响性能.</p></li></ul><p>多方尝试无果之后,决定自己绘制阴影.</p><p><strong>由于阴影实际上绘制在容器以外,以下代码有一个要求:其父容器必须设置android:clipChildren=”false”</strong></p><h4 id="首先为了方便使用-增加一个自定义容器-继承自FrameLayout即可"><a href="#首先为了方便使用-增加一个自定义容器-继承自FrameLayout即可" class="headerlink" title="首先为了方便使用,增加一个自定义容器,继承自FrameLayout即可."></a>首先为了方便使用,增加一个自定义容器,继承自FrameLayout即可.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MgCardContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FrameLayout</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-comment">/**关闭卡片样式*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CARD_FLAG_DISABLE = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**卡片头*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CARD_FLAG_TOP = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/**卡片中间*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CARD_FLAG_CENTER = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**卡片底部*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CARD_FLAG_BOTTOM = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">/**卡片四周*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CARD_FLAG_ALL_AROUND = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">private</span> Paint mPaint;<br>    <span class="hljs-comment">/**设置单独卡片时使用的rect*/</span><br>    <span class="hljs-keyword">private</span> RectF mRectF;<br>    <span class="hljs-comment">/**背景颜色,白天和晚上是不同的*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> backGroundColor;<br>    <span class="hljs-comment">/**阴影颜色,白天和晚上使用同一个颜色*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> shadowColor;<br>    <span class="hljs-comment">/**卡片样式,有0,1,2,3,4几种.*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cardFlag = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**卡片的圆角值*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cornerRadius = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**阴影大小*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> shadowWidth;<br>    <span class="hljs-comment">/**用来绘制阴影的画笔粗细*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> paintWidth;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MgCardContainer</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context);<br>        <span class="hljs-keyword">this</span>.context = context;<br>        initView();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MgCardContainer</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs);<br>        <span class="hljs-keyword">this</span>.context = context;<br>        initView();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MgCardContainer</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>        <span class="hljs-keyword">this</span>.context = context;<br>        initView();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initView</span><span class="hljs-params">()</span> </span>&#123;<br>        paintWidth = ScreenUtil.dip2px(context, <span class="hljs-number">1</span>);<br>        shadowWidth = ScreenUtil.dip2px(context, <span class="hljs-number">3</span>);<br>        cornerRadius = ScreenUtil.dip2px(context, <span class="hljs-number">3</span>);<br>        backGroundColor = getResources().getColor(R.color.color_v60_bg_with_card);<br>        shadowColor = Color.GRAY;<br>        mPaint = <span class="hljs-keyword">new</span> Paint();<br>        mPaint.setColor(backGroundColor);<br>        mPaint.setStyle(Paint.Style.STROKE);<br>        mPaint.setStrokeWidth(paintWidth);<br>        mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, shadowColor);<br>        mRectF = <span class="hljs-keyword">new</span> RectF();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="重写draw方法-在调用super之前-插入绘制阴影逻辑"><a href="#重写draw方法-在调用super之前-插入绘制阴影逻辑" class="headerlink" title="重写draw方法,在调用super之前,插入绘制阴影逻辑."></a>重写draw方法,在调用super之前,插入绘制阴影逻辑.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cardFlag != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> height = getHeight();<br>            <span class="hljs-keyword">int</span> width = getWidth();<br>            <span class="hljs-keyword">switch</span> (cardFlag) &#123;<br>                <span class="hljs-keyword">case</span> CARD_FLAG_TOP:<br>                    drawHeadShadow(canvas, width, height);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> CARD_FLAG_CENTER:<br>                    drawLeftAndRightShadow(canvas, width, height);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> CARD_FLAG_BOTTOM:<br>                    drawBottomShadow(canvas, width, height);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> CARD_FLAG_ALL_AROUND:<br>                    drawAllAroundShadow(canvas, width, height);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">super</span>.draw(canvas);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="针对卡片头部-卡片中间部分-卡片底部-单个卡片-分别进行阴影绘制"><a href="#针对卡片头部-卡片中间部分-卡片底部-单个卡片-分别进行阴影绘制" class="headerlink" title="针对卡片头部,卡片中间部分,卡片底部,单个卡片,分别进行阴影绘制."></a>针对卡片头部,卡片中间部分,卡片底部,单个卡片,分别进行阴影绘制.</h4><p>头部阴影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画卡片头部阴影</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHeadShadow</span><span class="hljs-params">(Canvas canvas, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, shadowColor);<br>    <span class="hljs-comment">//顶部阴影</span><br>    canvas.drawLine(cornerRadius, paintWidth, width - cornerRadius, paintWidth, mPaint);<br><br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, -shadowWidth, shadowColor);<br>    <span class="hljs-comment">//左侧阴影</span><br>    canvas.drawLine(paintWidth, cornerRadius, paintWidth, height + cornerRadius + shadowWidth, mPaint);<br>    <span class="hljs-comment">//右侧阴影</span><br>    canvas.drawLine(width - paintWidth, cornerRadius, width - paintWidth, height + cornerRadius + shadowWidth, mPaint);<br>&#125;<br></code></pre></td></tr></table></figure><p>中间阴影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画左右两边阴影</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLeftAndRightShadow</span><span class="hljs-params">(Canvas canvas, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, shadowWidth, shadowColor);<br>    <span class="hljs-comment">//左侧阴影</span><br>    canvas.drawLine(paintWidth, <span class="hljs-number">0</span>, paintWidth, height, mPaint);<br>    <span class="hljs-comment">//右侧阴影</span><br>    canvas.drawLine(width - paintWidth, <span class="hljs-number">0</span>, width - paintWidth, height, mPaint);<br>&#125;<br></code></pre></td></tr></table></figure><p>底部阴影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画底部卡片的阴影</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBottomShadow</span><span class="hljs-params">(Canvas canvas, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, shadowColor);<br>    <span class="hljs-comment">//底部阴影</span><br>    canvas.drawLine(cornerRadius, height - paintWidth, width - cornerRadius, height - paintWidth, mPaint);<br><br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, shadowWidth, shadowColor);<br>    <span class="hljs-comment">//左侧阴影</span><br>    canvas.drawLine(paintWidth, <span class="hljs-number">0</span>, paintWidth, height - cornerRadius, mPaint);<br>    <span class="hljs-comment">//右侧阴影</span><br>    canvas.drawLine(width - paintWidth, <span class="hljs-number">0</span>, width - paintWidth, height - cornerRadius, mPaint);<br>&#125;<br></code></pre></td></tr></table></figure><p>单个卡片四周绘制阴影</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 画单个卡片的阴影</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawAllAroundShadow</span><span class="hljs-params">(Canvas canvas, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mPaint.setShadowLayer(shadowWidth, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, shadowColor);<br>    mRectF.left = paintWidth;<br>    mRectF.top = paintWidth;<br>    mRectF.right = width - paintWidth;<br>    mRectF.bottom = height - paintWidth;<br>    canvas.drawRoundRect(mRectF, cornerRadius, cornerRadius, mPaint);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>之所以分成四个方法,而不是用组合的方式,是因为中间涉及阴影偏移,阴影线条长度有一些细微差异.可看代码自行感受.</strong></p><h4 id="顺便把自动增加margin和圆角的方法发上来"><a href="#顺便把自动增加margin和圆角的方法发上来" class="headerlink" title="顺便把自动增加margin和圆角的方法发上来."></a>顺便把自动增加margin和圆角的方法发上来.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开启卡片样式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cardFlag &#123;<span class="hljs-doctag">@link</span> MgCardContainer#CARD_FLAG_TOP&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> MgCardContainer#CARD_FLAG_CENTER&#125;&#123;<span class="hljs-doctag">@link</span> MgCardContainer#CARD_FLAG_BOTTOM&#125;&#123;<span class="hljs-doctag">@link</span> MgCardContainer#CARD_FLAG_ALL_AROUND&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableCardStyle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cardFlag)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.cardFlag = cardFlag;<br>    MarginLayoutParams pa = (MarginLayoutParams) getLayoutParams();<br>    <span class="hljs-comment">//第一步,先设置margin</span><br>    <span class="hljs-keyword">if</span> (getTag(R.id.dsl_tag_view_card) == <span class="hljs-keyword">null</span>) &#123;<br>        setTag(R.id.dsl_tag_view_card, cardFlag);<br>        Drawable drawable = getBackground();<br>        GradientDrawable gradientDrawable;<br>        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">instanceof</span> GradientDrawable) &#123;<br>            gradientDrawable = (GradientDrawable) drawable;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            gradientDrawable = <span class="hljs-keyword">new</span> GradientDrawable();<br>            gradientDrawable.setColor(backGroundColor);<br>        &#125;<br>        pa.leftMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>        pa.rightMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">switch</span> (cardFlag) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                pa.topMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                gradientDrawable.setCornerRadii(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;cornerRadius, cornerRadius, cornerRadius, cornerRadius, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                gradientDrawable.setCornerRadius(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                pa.bottomMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                gradientDrawable.setCornerRadii(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cornerRadius, cornerRadius, cornerRadius, cornerRadius&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                pa.topMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                pa.bottomMargin += ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                gradientDrawable.setCornerRadius(cornerRadius);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        setBackground(gradientDrawable);<br>        setLayoutParams(pa);<br>        invalidate();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 禁用卡片样式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disableCardStyle</span><span class="hljs-params">()</span> </span>&#123;<br>    cardFlag = <span class="hljs-number">0</span>;<br>    MarginLayoutParams pa = (MarginLayoutParams) getLayoutParams();<br>    <span class="hljs-keyword">if</span> (getTag(R.id.dsl_tag_view_card) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> flag = (<span class="hljs-keyword">int</span>) getTag(R.id.dsl_tag_view_card);<br>        pa.leftMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>        pa.rightMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">switch</span> (flag) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                pa.topMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                pa.bottomMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                pa.topMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                pa.bottomMargin -= ScreenUtil.dip2px(context, <span class="hljs-number">6</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        setTag(R.id.dsl_tag_view_card, <span class="hljs-keyword">null</span>);<br>        setBackgroundColor(Color.TRANSPARENT);<br>        setLayoutParams(pa);<br>        invalidate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就这样了.展示效果完美,适配系统暗夜模式,无毛边,无越界.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android Q适配笔记</title>
    <link href="/2019/07/06/android-Q%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/07/06/android-Q%E9%80%82%E9%85%8D%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="关于非SDK接口管控"><a href="#关于非SDK接口管控" class="headerlink" title="关于非SDK接口管控"></a>关于非SDK接口管控</h3><p><strong>首先要说明的是,仅在targetSdkVersion调整为29(android Q)的情况下才需要考虑这一点.<br>如果应用的targetSdkVersion还停留在26(android O)甚至更低,在这一方面可以不用做任何变更.</strong></p><p>官方对于非sdk接口管控是通过黑名单/灰名单列表来管控的.<br>targetSdkVersion被看做是应用的一项”声明”,代表应用已经针对指定版本的平台做了适配工作,承诺会遵守对应平台的新特性(隐私方面,安全方面,等等).</p><p><strong>兼容</strong>-无论如何,android高版本需要支持面向低版本开发的应用<br><strong>适配</strong>-开发者已知高版本特性,并对其做了针对性处理</p><blockquote><p>blacklist:在targetSdkVersion对应的平台上,该方法不允许调用<br>greylist-max-p:若targetSdkVersion&lt;=P,警告.否则P以上的设备不允许调用.<br>greylist-max-o:若targetSdkVersion&lt;=O,警告.否则O以上的设备不允许调用.<br>greylist:若targetSdkVersion&gt;=P,警告,否则正常调用.</p></blockquote><p>检查方式有三种,建议结合使用:</p><ol><li>在android Q设备上运行程序,以Accessing hidden为关键字在log中筛选.</li><li>在StrictMode中打开detectNonSdkApiUsage.</li><li>使用官方工具veridex扫描apk,有误差,需要以实际logcat为准.</li></ol><p><strong>改造方式:</strong></p><p>部分方法是为了将高版本上的优化措施应用到低版本上,因此调用时可以判断sdk版本,高版本跳过.<br>另外大多数方法在调用时都已经加上了try catch,一般保证代码执行流程无影响即可.</p><h3 id="关于存储沙箱"><a href="#关于存储沙箱" class="headerlink" title="关于存储沙箱"></a>关于存储沙箱</h3><p>一般涉及到此类场景,都是保存图片到相册.只需针对处理即可.<br>或者直接使用requestLegacyExternalStorage=true来兼容.</p><h3 id="关于compileSdkVersion升级带来的androidX迁移"><a href="#关于compileSdkVersion升级带来的androidX迁移" class="headerlink" title="关于compileSdkVersion升级带来的androidX迁移"></a>关于compileSdkVersion升级带来的androidX迁移</h3><p>从AS中的建议来说,要求是compileSdkVersion&gt;=targetSdkVersion.因此将targetSdkVersion升级后,对应的compileSdkVersion和support库也需要升级.</p><p>而从android 29开始,andoridX代替了support库.很大一部分工作量在于andoridX迁移.</p><p>在项目根目录的gradle.properties中增加两行代码,然后使用AS自动迁移.</p><p><strong>android.useAndroidX=true</strong></p><p><strong>android.enableJetifier=true</strong><br>//可以将library中的support依赖自动转换为androidX依赖.不论是远程引用还是本地library,不论是java代码还是xml中的控件.</p><p>另外附上需要手动替换的部分列表:</p><blockquote><p>import android.support.annotation.NonNull<br>import androidx.annotation.NonNull</p><p>import android.support.annotation.Nullable<br>import androidx.annotation.Nullable</p><p>import android.support.v7.widget<br>import androidx.appcompat.widget</p><p>import androidx.appcompat.widget.CardView<br>import androidx.cardview.widget.CardView</p><p>android.support.v7.appcompat.R<br>androidx.appcompat.R</p><p>import android.support.annotation<br>import androidx.annotation</p><p>import androidx.appcompat.widget.RecyclerView<br>import androidx.recyclerview.widget.RecyclerView</p><p>import androidx.core.app.Fragment<br>import androidx.fragment.app.Fragment</p><p>import androidx.appcompat.widget.LinearLayoutManager<br>import androidx.recyclerview.widget.LinearLayoutManager</p><p>import androidx.core.view.PagerAdapter<br>import androidx.viewpager.widget.PagerAdapter</p><p>import androidx.core.view.ViewPager<br>import androidx.viewpager.widget.ViewPager</p><p>import androidx.core.app.DialogFragment<br>import androidx.fragment.app.DialogFragment</p><p>import androidx.appcompat.widget.SimpleItemAnimator<br>import androidx.recyclerview.widget.SimpleItemAnimator</p><p>import androidx.appcompat.widget.GridLayoutManager<br>import androidx.recyclerview.widget.GridLayoutManager</p><p>import android.support.v7.app.AppCompatActivity<br>import androidx.appcompat.app.AppCompatActivity</p><p>import android.support.v7.app.AlertDialog<br>import androidx.appcompat.app.AlertDialog</p><p>import androidx.core.content.LocalBroadcastManager<br>import androidx.localbroadcastmanager.content.LocalBroadcastManager</p><p>import android.support.design.widget.AppBarLayout<br>import com.google.android.material.appbar.AppBarLayout</p><p>import androidx.core.widget.SwipeRefreshLayout<br>import androidx.swiperefreshlayout.widget.SwipeRefreshLayout</p><p>import androidx.appcompat.widget.OrientationHelper<br>import androidx.recyclerview.widget.OrientationHelper</p><p>&lt;android.support.v7.widget.AppCompatImageView<br>&lt;androidx.appcompat.widget.AppCompatImageView</p><p>&lt;androidx.core.view.ViewPager<br>&lt;androidx.viewpager.widget.ViewPager</p><p>&lt;android.support.v7.widget.RecyclerView<br>&lt;androidx.recyclerview.widget.RecyclerView</p><p>&lt;/android.support.v7.widget.RecyclerView&gt;<br>&lt;/androidx.recyclerview.widget.RecyclerView&gt;</p><p>&lt;android.support.v7.widget.SwitchCompat<br>&lt;androidx.appcompat.widget.SwitchCompat</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一次崩溃事件的调查过程</title>
    <link href="/2019/05/21/%E4%B8%80%E6%AC%A1%E5%B4%A9%E6%BA%83%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E6%9F%A5%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/05/21/%E4%B8%80%E6%AC%A1%E5%B4%A9%E6%BA%83%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E6%9F%A5%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>周六晚,收到反馈称新浪微博上有数十起用户在发表话题声称启动闪退.观察对应机型后,去往对应的应用商店查看评论,发现投诉闪退用户集中在<strong>O/V平台</strong>.且多为<strong>6.0及以下</strong>用户.</p><p>通过vivo开发者平台进行真机测试,完全无法重现,一方面新版本发布在即,需要确定问题在新版本中是否还存在,另一方面崩溃还在持续产生,<strong>问题比较严重</strong>.</p><p>第二天去公司排查问题,在意见反馈平台也发现大量闪退反馈,分析反馈上来的日志多为卸载重装后产生,多数没有价值,为数不多的有效日志中发现了breakpad的dump操作,且dump size普遍大于1,说明上一次so崩溃后,启动时dump过程中又崩溃了,有dmp文件累积.</p><ul><li>崩溃出现在oppo/vivo机型.</li><li>崩溃出现在6.0及以下机型.</li><li>友盟的java crash率无异常.</li><li>反馈上传日志中breakpad dump操作.</li></ul><p>根据以上特征可以确定是so崩溃.</p><hr><p>既然是so崩溃,则需要去后台的错误收集平台查看dump完成后上传的堆栈信息,可惜的是由于是启动即崩溃,很多日志都没能上传成功.</p><p>这里发现一个优化点:</p><blockquote><p>由于目前崩溃日志放在Android/data目录下,卸载时会清空,导致启动即崩溃的日志无法在卸载/清除数据后得到保留,这是一个很关键的点,需要改善.</p></blockquote><p>经过对意见反馈日志的筛选,终于找出少量上传成功的设备,于是根据设备id去错误收集平台查看.分析日志发现导致崩溃的是一个叫libnative_lib.so的文件导致,这个文件不在apk文件中,好像是个系统so?<em>(由于so名字问题,这里浪费了很多时间,后面详细介绍)</em></p><p>由于看起来是系统so的崩溃,日志所能提供的信息就到此为止了.换个思路,从<strong>改动点</strong>查起.</p><h3 id="检查一下最近的版本发布"><a href="#检查一下最近的版本发布" class="headerlink" title="检查一下最近的版本发布"></a>检查一下最近的版本发布</h3><p>1.意见反馈的都是线上最新版本,其他版本没有出现意见反馈.<em>(由于卸载后重装一般会使用线上最新版本,所以这里并不能代表旧版本没有出现崩溃,但是当时没有考虑到这一点)</em></p><p>2.崩溃发生在新版本上线一周后.</p><p>这里有两个分析点:</p><ul><li>新版本和上一版本在so方面有何不同?</li><li>上线一周后,有没有什么动态配置的信息发生了变更?</li></ul><h4 id="新旧版本比对"><a href="#新旧版本比对" class="headerlink" title="新旧版本比对"></a>新旧版本比对</h4><p>经过apk文件的so比对,发现播放器组件,下载组件,广告组件在最近版本发布中有修改.于是一边联系对应开发方确认修改点,一边着手备用方案一:</p><blockquote><p>回滚携带so且有变更的sdk库,保证新版本稳定发布.</p></blockquote><p>很可惜的是,根据收集到的多方sdk修改点,结合崩溃产生场景,并没有关联.再加上回滚过程中产生其他编译问题/运行问题,这条路先放一边.</p><h4 id="配置接口变更"><a href="#配置接口变更" class="headerlink" title="配置接口变更"></a>配置接口变更</h4><p>目前配置接口主要包含两方面:app自身的配置接口和广告配置接口.</p><p>首先找上的是广告配置接口,因为这方面由于接入广告方众多,且已确定存在第三方动态加载dex和so行为,可控性不够,嫌疑最大.首先通知广告部门依次停掉可疑的广告开关,待5分钟生效后,与联系上的用户核查是否继续崩溃,需要一些时间,而且涉及广告缓存问题需要更细致的检查.</p><p>同时app自身的配置接口也不能放下,直接联系接口开发人员咨询在那个时间点附近有无修改配置信息,得知当天正好有两个修改点.于是开始检查对应配置修改对app的影响.</p><p><strong>可惜的是,通过本地map local未能重现.</strong></p><p>到此为止,动态配置的可能性好像被排除了.无法重现意味着无法确认修改方式是否有效,我们甚至一度怀疑是不是某些我们集成的某些不受控sdk针对长沙地区做了特别处理…</p><p>难道除了使用自己心里也没底的回滚sdk方案,就没有别的路了么?</p><hr><p><em>就在快要放弃的时候,转机来了.</em></p><h3 id="获得崩溃现场"><a href="#获得崩溃现场" class="headerlink" title="获得崩溃现场"></a>获得崩溃现场</h3><p>在与负责自身配置接口的后台开发人员沟通过程中,得知他的手机也是一打开app就崩溃.在再三叮嘱保存现场,千万不要卸载或者清除app之后,同事立马驱车前往取手机…</p><p>拿回手机后,确实进入app就崩溃.虽然由于是release版本,无法进入私有目录,但是插上电脑可以看到日志还是非常有价值的.</p><p>然而现实很残酷,插上手机后依然没有太多有效信息.只是确认了两个问题:</p><ul><li>现在可以完全确认是so崩溃了.</li><li>崩溃最后在这个so:libnative_lib.so.到底是哪里来的?<em>(名字带来的误解仍然存在)</em></li></ul><p>此时与用户的沟通的过程中收到一个重要反馈:断网情况下进入app,不崩溃.</p><p><strong>毫无疑问和某个配置有关.</strong></p><p>具体是哪个配置呢?app启动时调用的接口多达几十个.本来想着连上charles,一个一个去hook,来查找是哪个接口原因.但是接下来的一个事实让我懵了:</p><blockquote><p>手机连接charles代理,将所有接口调用都加入black list,启动app仍然崩溃.</p></blockquote><p>断网不崩溃,但屏蔽所有接口又崩溃,看来是之前某个配置的缓存在”发挥作用”:<br>拉配置之前会检查网络状态,若无网则不请求也不使用缓存,相当于未开启该功能.但是如果通过黑名单方式使接口请求失败了,就会使用上次下载的缓存配置.</p><p><strong>但是目前无法通过清除数据来确认这一点,唯一的现场不能丢.</strong></p><p>到底是哪个缓存有问题呢?能否把缓存拉出来分析,或者复制到另一台手机上看是否能重现?</p><p>考虑到这是一台未root的oppo手机,中间尝试导出app私有目录下的相关文件未果.</p><h3 id="接口breakpoint"><a href="#接口breakpoint" class="headerlink" title="接口breakpoint"></a>接口breakpoint</h3><p>既然不能用黑名单,那就在接口请求上面打断点好了.通过对启动接口调用使用二分法排除之后,终于确定了一个有问题的接口.</p><p>原来这个libnative_lib.so竟然是接口下发的.</p><blockquote><p>libnative_lib.so并不是什么系统so.仅仅是一些c++官方教程里面喜欢拿这个当做默认名字.</p></blockquote><p>在这个接口打上断点后,可以维持5s左右不崩溃了,5s后接口超时,适用接口错误场景,会加载上次缓存数据,继续崩溃.</p><p>原因找到了,接下来就是对这个配置接口做一些修改,看能否通过其开关配置停掉对应的so加载.</p><p>改了下载路径后,终于不崩溃了.</p><p>现在可以把问题抛给对应sdk提供方,让他们去寻找修复方案了.</p><hr><h3 id="总结一下本次事故分析过程"><a href="#总结一下本次事故分析过程" class="headerlink" title="总结一下本次事故分析过程."></a>总结一下本次事故分析过程.</h3><p>分析过程改进点:</p><ol><li>不要被so文件名字迷惑,对系统自带so要有了解.</li><li>如果能确定是某个动态下发的文件导致,可以直接在charles中的response中搜索这个名字.</li></ol><p>app开发风险点:</p><ol><li>第三方动态加载dex和so过程不可控.</li><li>日志不能放在apk目录,应该在/sdcard中单独使用文件夹存储,反之后续启动即崩溃的场景中,用户安装其他版本后无法保留关键日志.</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>https证书忽略有效期校验</title>
    <link href="/2018/02/08/https%E8%AF%81%E4%B9%A6%E5%BF%BD%E7%95%A5%E6%9C%89%E6%95%88%E6%9C%9F%E6%A0%A1%E9%AA%8C/"/>
    <url>/2018/02/08/https%E8%AF%81%E4%B9%A6%E5%BF%BD%E7%95%A5%E6%9C%89%E6%95%88%E6%9C%9F%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>最近公司的数据统计平台报了大量ssl证书错误.类似于这种</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.ssl</span><span class="hljs-selector-class">.sslhandshakeexception</span>: <br><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.org</span><span class="hljs-selector-class">.bouncycastle</span><span class="hljs-selector-class">.jce</span><span class="hljs-selector-class">.exception</span><span class="hljs-selector-class">.extcertpathvalidatorexception</span>: <br><span class="hljs-selector-tag">could</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">validate</span> <span class="hljs-selector-tag">certificate</span>: <br><span class="hljs-selector-tag">current</span> <span class="hljs-selector-tag">time</span>: <span class="hljs-selector-tag">mon</span> <span class="hljs-selector-tag">jan</span> 04 13<span class="hljs-selector-pseudo">:33</span><span class="hljs-selector-pseudo">:18</span> 格林尼治标准时间+0800 2010, <br><span class="hljs-selector-tag">validation</span> <span class="hljs-selector-tag">time</span>: <span class="hljs-selector-tag">fri</span> <span class="hljs-selector-tag">mar</span> 08 20<span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-pseudo">:00</span> 格林尼治标准时间+0800 2013<br></code></pre></td></tr></table></figure><p>拿着上报信息中的链接在浏览器打开,并没有证书错误,我们的后台也并没有做什么自定义证书,完全是系统默认的SSL Context.<br>结合异常信息,并检查对应域名的证书信息,可以断定是<strong>手机系统时间修改后,超出证书有效期</strong>,导致证书校验错误.<br>虽说这本质上是一个安全性措施,但是修改系统时间的场景也无法完全避免.初步推测是某些云测平台的系统时间有误导致.</p><p><strong>信任所有证书肯定是不行的.不仅有安全问题,同时各种app安全扫描平台基本上都把这个当高危项目.</strong></p><p>那么问题来了,如何单单将证书时间错误的问题忽略掉呢?</p><p>一开始我是这么干的,检测到指定Exception时,忽略掉.<br>关键代码都在这个自定义的TrustManager里面.在checkServerTrusted中对异常类型进行检查.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> TrustManager[] trustAllCerts = <span class="hljs-keyword">new</span> TrustManager[]&#123;<span class="hljs-keyword">new</span> X509TrustManager() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkClientTrusted</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                    java.security.cert.X509Certificate[] chain,</span></span><br><span class="hljs-function"><span class="hljs-params">                    String authType)</span> <span class="hljs-keyword">throws</span> CertificateException </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkServerTrusted</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                    java.security.cert.X509Certificate[] chain,</span></span><br><span class="hljs-function"><span class="hljs-params">                    String authType)</span> <span class="hljs-keyword">throws</span> CertificateException </span>&#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    defaultTrustManager.checkServerTrusted(chain, authType);<br>                &#125; <span class="hljs-keyword">catch</span> (CertificateException e) &#123;<br>                    e.printStackTrace();<br>                    Throwable t = e;<br>                    <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> CertificateExpiredException<br>                                || t <span class="hljs-keyword">instanceof</span> CertificateNotYetValidException)<br>                            <span class="hljs-keyword">return</span>;<br>                        t = t.getCause();<br>                    &#125;<br>                    <span class="hljs-keyword">throw</span> e;<br>                &#125;<br><br>            &#125;<br></code></pre></td></tr></table></figure><p>这里面有个问题:<br>通常这个证书链是包含多个证书的,如果一检测到有效期相关的异常就return,会导致后面的所有证书都被信任了.不太安全.</p><p>更坑爹的是,实际使用中抛出来的是<strong>CertPathValidatorException</strong>!!!看这个异常的描述,不能保证触发它的一定是有效期问题.</p><p>既然TrustManager不能做文章了.那就再往下一层.在X509Certificate上看看吧.</p><p>X509Certificate有很多方法,其中和本文相关的<strong>checkValidity()**和</strong>checkValidity(Date date)**就是证书有效期检查相关的方法.</p><p>于是用自定义的X509Certificate封装一层,把这两个方法给屏蔽掉.就可以既不影响其他的证书校验,就可以忽略日期异常了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EternalCertificate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">X509Certificate</span> </span>&#123;<br><span class="hljs-comment">//原始X509Certificate,其他校验流程还是要走的</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> X509Certificate originalCertificate;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EternalCertificate</span><span class="hljs-params">(X509Certificate originalCertificate)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.originalCertificate = originalCertificate;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkValidity</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CertificateExpiredException, CertificateNotYetValidException </span>&#123;<br>            <span class="hljs-comment">// 这里什么都不做,忽略掉有效期检查</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkValidity</span><span class="hljs-params">(Date date)</span> <span class="hljs-keyword">throws</span> CertificateExpiredException, CertificateNotYetValidException </span>&#123;<br>            <span class="hljs-comment">// 这里什么都不做,忽略掉有效期检查</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getVersion();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title">getSerialNumber</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSerialNumber();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">getIssuerDN</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getIssuerDN();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">getSubjectDN</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSubjectDN();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getNotBefore</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getNotBefore();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getNotAfter</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getNotAfter();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getTBSCertificate() <span class="hljs-keyword">throws</span> CertificateEncodingException &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getTBSCertificate();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getSignature() &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSignature();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSigAlgName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSigAlgName();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSigAlgOID</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSigAlgOID();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getSigAlgParams() &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSigAlgParams();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[] getIssuerUniqueID() &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getIssuerUniqueID();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[] getSubjectUniqueID() &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getSubjectUniqueID();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span>[] getKeyUsage() &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getKeyUsage();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBasicConstraints</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getBasicConstraints();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getEncoded() <span class="hljs-keyword">throws</span> CertificateEncodingException &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getEncoded();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verify</span><span class="hljs-params">(PublicKey key)</span> <span class="hljs-keyword">throws</span> CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException,</span><br><span class="hljs-function">                SignatureException </span>&#123;<br>            originalCertificate.verify(key);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verify</span><span class="hljs-params">(PublicKey key, String sigProvider)</span> <span class="hljs-keyword">throws</span> CertificateException, NoSuchAlgorithmException, InvalidKeyException,</span><br><span class="hljs-function">                NoSuchProviderException, SignatureException </span>&#123;<br>            originalCertificate.verify(key, sigProvider);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.toString();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> PublicKey <span class="hljs-title">getPublicKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getPublicKey();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getCriticalExtensionOIDs</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getCriticalExtensionOIDs();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getExtensionValue(String oid) &#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getExtensionValue(oid);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getNonCriticalExtensionOIDs</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.getNonCriticalExtensionOIDs();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasUnsupportedCriticalExtension</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> originalCertificate.hasUnsupportedCriticalExtension();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里是checkServerTrusted中对证书链的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkServerTrusted</span><span class="hljs-params">(X509Certificate[] chain, String authType)</span> <span class="hljs-keyword">throws</span> CertificateException </span>&#123;<br>        chain = Arrays.copyOf(chain, chain.length);<br>        X509Certificate[] newChain = <span class="hljs-keyword">new</span> X509Certificate[chain.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chain.length; i++) &#123;<br>            newChain[i] = <span class="hljs-keyword">new</span> EternalCertificate(chain[i]);<br>        &#125;<br>        chain = newChain;<br>        <span class="hljs-keyword">this</span>.innerTrustManager.checkServerTrusted(chain, authType);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里innerTrustManager是默认的trustManager.可以这样拿到,传给自定义的TrustManager,以便调用原本的相关方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());<br>trustManagerFactory.init((KeyStore) <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">final</span> X509TrustManager defaultTrustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>到这里问题差不多解决了.但是为安全着想,以及影响范围最小化的原则,我们最好是针对本公司的证书做这样的忽略.这里涉及到证书结构.顺便学习了一波.<br>Android用的是X509证书格式.这里是一个证书示例.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Certificate</span>:<br>    <span class="hljs-attribute">Data</span>:<br>        <span class="hljs-attribute">Version</span>: <span class="hljs-number">3</span> (<span class="hljs-number">0</span>x<span class="hljs-number">2</span>)<br>        <span class="hljs-attribute">Serial</span> Number:<br>            <span class="hljs-attribute">05</span>:<span class="hljs-number">6</span>f:a<span class="hljs-number">7</span>:c<span class="hljs-number">7</span>:<span class="hljs-number">98</span>:b<span class="hljs-number">4</span>:<span class="hljs-number">9</span>a:cd:<span class="hljs-number">68</span>:a<span class="hljs-number">9</span>:<span class="hljs-number">39</span>:<span class="hljs-number">37</span>:<span class="hljs-number">7</span>b:bd:<span class="hljs-number">66</span>:<span class="hljs-number">73</span><br>    <span class="hljs-attribute">Signature</span> Algorithm: sha<span class="hljs-number">256</span>WithRSAEncryption<br>        <span class="hljs-attribute">Issuer</span>: C=US, O=DigiCert Inc, CN=DigiCert SHA<span class="hljs-number">2</span> Secure Server CA<br>        <span class="hljs-attribute">Validity</span><br>            <span class="hljs-attribute">Not</span> Before: Dec  <span class="hljs-number">5</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">2017</span> GMT<br>            <span class="hljs-attribute">Not</span> After : Feb  <span class="hljs-number">5</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">2019</span> GMT<br>        <span class="hljs-attribute">Subject</span>: C=CN, L=Changsha, O=xxxxxx xxxx xxxxx xxxxx Co., Ltd, OU=IT, CN=*.xxx.com<br>        <span class="hljs-attribute">Subject</span> Public Key Info:<br>            <span class="hljs-attribute">Public</span> Key Algorithm: rsaEncryption<br>                <span class="hljs-attribute">Public</span>-Key: (<span class="hljs-number">2048</span> bit)<br>                <span class="hljs-attribute">Modulus</span>:<br>                    <span class="hljs-attribute">00</span>:c<span class="hljs-number">0</span>:<span class="hljs-number">31</span>:<span class="hljs-number">45</span>:<span class="hljs-number">83</span>:<span class="hljs-number">9</span>f:<span class="hljs-number">01</span>:<span class="hljs-number">81</span>:e<span class="hljs-number">8</span>:b<span class="hljs-number">1</span>:<span class="hljs-number">9</span>f:<span class="hljs-number">75</span>:ed:<span class="hljs-number">9</span>b:<span class="hljs-number">45</span>:<br>                    <span class="hljs-attribute">04</span>:<span class="hljs-number">05</span>:<span class="hljs-number">3</span>b:<span class="hljs-number">6</span>e:<span class="hljs-number">14</span>:f<span class="hljs-number">1</span>:<span class="hljs-number">68</span>:<span class="hljs-number">35</span>:b<span class="hljs-number">2</span>:<span class="hljs-number">80</span>:d<span class="hljs-number">1</span>:bc:d<span class="hljs-number">3</span>:<span class="hljs-number">53</span>:<span class="hljs-number">40</span>:<br>                    <span class="hljs-attribute">ac</span>:b<span class="hljs-number">4</span>:b<span class="hljs-number">6</span>:fe:<span class="hljs-number">8</span>d:f<span class="hljs-number">2</span>:bf:c<span class="hljs-number">1</span>:<span class="hljs-number">58</span>:f<span class="hljs-number">8</span>:b<span class="hljs-number">6</span>:a<span class="hljs-number">8</span>:<span class="hljs-number">54</span>:b<span class="hljs-number">8</span>:ae:<br>                    <span class="hljs-attribute">bf</span>:<span class="hljs-number">01</span>:b<span class="hljs-number">8</span>:<span class="hljs-number">77</span>:<span class="hljs-number">10</span>:<span class="hljs-number">3</span>a:<span class="hljs-number">7</span>b:f<span class="hljs-number">8</span>:<span class="hljs-number">33</span>:<span class="hljs-number">90</span>:<span class="hljs-number">67</span>:<span class="hljs-number">01</span>:<span class="hljs-number">70</span>:d<span class="hljs-number">2</span>:cc:<br>                    <span class="hljs-attribute">80</span>:<span class="hljs-number">91</span>:c<span class="hljs-number">0</span>:<span class="hljs-number">02</span>:<span class="hljs-number">7</span>c:b<span class="hljs-number">0</span>:<span class="hljs-number">87</span>:<span class="hljs-number">8</span>d:<span class="hljs-number">8</span>d:c<span class="hljs-number">0</span>:<span class="hljs-number">30</span>:<span class="hljs-number">3</span>c:e<span class="hljs-number">2</span>:<span class="hljs-number">44</span>:<span class="hljs-number">69</span>:<br>                    <span class="hljs-attribute">ef</span>:<span class="hljs-number">8</span>a:<span class="hljs-number">07</span>:<span class="hljs-number">80</span>:b<span class="hljs-number">0</span>:b<span class="hljs-number">9</span>:<span class="hljs-number">8</span>a:<span class="hljs-number">8</span>e:e<span class="hljs-number">9</span>:fd:<span class="hljs-number">28</span>:<span class="hljs-number">08</span>:<span class="hljs-number">9</span>b:b<span class="hljs-number">5</span>:<span class="hljs-number">7</span>f:<br>                    <span class="hljs-attribute">ac</span>:<span class="hljs-number">60</span>:<span class="hljs-number">5</span>d:<span class="hljs-number">6</span>e:b<span class="hljs-number">2</span>:c<span class="hljs-number">9</span>:c<span class="hljs-number">9</span>:b<span class="hljs-number">4</span>:fc:<span class="hljs-number">12</span>:<span class="hljs-number">0</span>a:df:<span class="hljs-number">1</span>a:<span class="hljs-number">5</span>a:<span class="hljs-number">0</span>b:<br>                    <span class="hljs-attribute">39</span>:<span class="hljs-number">8</span>d:<span class="hljs-number">5</span>c:<span class="hljs-number">7</span>f:f<span class="hljs-number">7</span>:<span class="hljs-number">7</span>d:<span class="hljs-number">16</span>:<span class="hljs-number">1</span>a:<span class="hljs-number">6</span>a:f<span class="hljs-number">3</span>:a<span class="hljs-number">7</span>:dd:<span class="hljs-number">2</span>c:<span class="hljs-number">81</span>:aa:<br>                    <span class="hljs-attribute">b8</span>:<span class="hljs-number">83</span>:c<span class="hljs-number">2</span>:<span class="hljs-number">60</span>:<span class="hljs-number">11</span>:f<span class="hljs-number">6</span>:<span class="hljs-number">05</span>:<span class="hljs-number">0</span>d:<span class="hljs-number">6</span>e:<span class="hljs-number">8</span>b:<span class="hljs-number">75</span>:<span class="hljs-number">36</span>:<span class="hljs-number">44</span>:<span class="hljs-number">74</span>:a<span class="hljs-number">0</span>:<br>                    <span class="hljs-attribute">96</span>:fd:<span class="hljs-number">86</span>:<span class="hljs-number">36</span>:<span class="hljs-number">30</span>:<span class="hljs-number">58</span>:<span class="hljs-number">90</span>:<span class="hljs-number">6</span>a:<span class="hljs-number">13</span>:<span class="hljs-number">48</span>:a<span class="hljs-number">7</span>:c<span class="hljs-number">9</span>:<span class="hljs-number">16</span>:af:<span class="hljs-number">72</span>:<br>                    <span class="hljs-attribute">58</span>:a<span class="hljs-number">5</span>:f<span class="hljs-number">1</span>:<span class="hljs-number">3</span>c:<span class="hljs-number">39</span>:<span class="hljs-number">95</span>:<span class="hljs-number">93</span>:e<span class="hljs-number">4</span>:e<span class="hljs-number">4</span>:<span class="hljs-number">78</span>:<span class="hljs-number">78</span>:f<span class="hljs-number">4</span>:<span class="hljs-number">68</span>:<span class="hljs-number">4</span>a:<span class="hljs-number">59</span>:<br>                    <span class="hljs-attribute">0c</span>:e<span class="hljs-number">4</span>:e<span class="hljs-number">2</span>:<span class="hljs-number">7</span>d:<span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">8</span>a:<span class="hljs-number">91</span>:ea:<span class="hljs-number">5</span>d:<span class="hljs-number">5</span>b:<span class="hljs-number">95</span>:d<span class="hljs-number">0</span>:dc:a<span class="hljs-number">4</span>:<br>                    <span class="hljs-attribute">cb</span>:<span class="hljs-number">64</span>:<span class="hljs-number">9</span>c:<span class="hljs-number">33</span>:<span class="hljs-number">98</span>:db:<span class="hljs-number">4</span>b:<span class="hljs-number">52</span>:<span class="hljs-number">5</span>e:fa:<span class="hljs-number">0</span>c:<span class="hljs-number">3</span>a:f<span class="hljs-number">4</span>:<span class="hljs-number">45</span>:f<span class="hljs-number">6</span>:<br>                    <span class="hljs-attribute">98</span>:<span class="hljs-number">04</span>:<span class="hljs-number">81</span>:ec:<span class="hljs-number">45</span>:<span class="hljs-number">1</span>e:<span class="hljs-number">60</span>:f<span class="hljs-number">9</span>:a<span class="hljs-number">2</span>:<span class="hljs-number">23</span>:<span class="hljs-number">6</span>c:<span class="hljs-number">84</span>:f<span class="hljs-number">7</span>:e<span class="hljs-number">2</span>:d<span class="hljs-number">0</span>:<br>                    <span class="hljs-attribute">bb</span>:<span class="hljs-number">12</span>:<span class="hljs-number">70</span>:<span class="hljs-number">7</span>f:e<span class="hljs-number">1</span>:<span class="hljs-number">83</span>:f<span class="hljs-number">6</span>:<span class="hljs-number">9</span>b:f<span class="hljs-number">2</span>:<span class="hljs-number">6</span>f:<span class="hljs-number">9</span>d:<span class="hljs-number">53</span>:ce:<span class="hljs-number">57</span>:<span class="hljs-number">3</span>d:<br>                    <span class="hljs-attribute">60</span>:<span class="hljs-number">90</span>:db:a<span class="hljs-number">6</span>:b<span class="hljs-number">7</span>:e<span class="hljs-number">0</span>:<span class="hljs-number">15</span>:bb:<span class="hljs-number">7</span>a:<span class="hljs-number">7</span>e:b<span class="hljs-number">0</span>:<span class="hljs-number">53</span>:ad:<span class="hljs-number">0</span>a:<span class="hljs-number">97</span>:<br>                    <span class="hljs-attribute">c2</span>:<span class="hljs-number">91</span>:<span class="hljs-number">4</span>a:<span class="hljs-number">5</span>c:a<span class="hljs-number">9</span>:<span class="hljs-number">81</span>:<span class="hljs-number">9</span>a:ee:ad:<span class="hljs-number">17</span>:<span class="hljs-number">80</span>:<span class="hljs-number">68</span>:a<span class="hljs-number">4</span>:<span class="hljs-number">50</span>:<span class="hljs-number">74</span>:<br>                    <span class="hljs-attribute">19</span>:c<span class="hljs-number">1</span><br>                <span class="hljs-attribute">Exponent</span>: <span class="hljs-number">65537</span> (<span class="hljs-number">0</span>x<span class="hljs-number">10001</span>)<br>        <span class="hljs-attribute">X509v3</span> extensions:<br>            <span class="hljs-attribute">X509v3</span> Authority Key Identifier: <br>                <span class="hljs-attribute">keyid</span>:<span class="hljs-number">0</span>F:<span class="hljs-number">80</span>:<span class="hljs-number">61</span>:<span class="hljs-number">1</span>C:<span class="hljs-number">82</span>:<span class="hljs-number">31</span>:<span class="hljs-number">61</span>:D<span class="hljs-number">5</span>:<span class="hljs-number">2</span>F:<span class="hljs-number">28</span>:E<span class="hljs-number">7</span>:<span class="hljs-number">8</span>D:<span class="hljs-number">46</span>:<span class="hljs-number">38</span>:B<span class="hljs-number">4</span>:<span class="hljs-number">2</span>C:E<span class="hljs-number">1</span>:C<span class="hljs-number">6</span>:D<span class="hljs-number">9</span>:E<span class="hljs-number">2</span><br><br>            <span class="hljs-attribute">X509v3</span> Subject Key Identifier: <br>                <span class="hljs-attribute">EF</span>:<span class="hljs-number">85</span>:<span class="hljs-number">1</span>D:<span class="hljs-number">4</span>E:E<span class="hljs-number">3</span>:<span class="hljs-number">57</span>:C<span class="hljs-number">2</span>:<span class="hljs-number">03</span>:<span class="hljs-number">63</span>:BD:<span class="hljs-number">70</span>:C<span class="hljs-number">0</span>:<span class="hljs-number">0</span>F:<span class="hljs-number">4</span>D:E<span class="hljs-number">5</span>:<span class="hljs-number">58</span>:<span class="hljs-number">42</span>:<span class="hljs-number">60</span>:E<span class="hljs-number">8</span>:<span class="hljs-number">72</span><br>            <span class="hljs-attribute">X509v3</span> Subject Alternative Name: <br>                <span class="hljs-attribute">DNS</span>:*.xxx.com, DNS:*.api.xxx.com, DNS:*.bz.xxx.com, DNS:*.log.xxx.com<br>            <span class="hljs-attribute">X509v3</span> Key Usage: critical<br>                <span class="hljs-attribute">Digital</span> Signature, Key Encipherment<br>            <span class="hljs-attribute">X509v3</span> Extended Key Usage: <br>                <span class="hljs-attribute">TLS</span> Web Server Authentication, TLS Web Client Authentication<br>            <span class="hljs-attribute">X509v3</span> CRL Distribution Points: <br><br>                <span class="hljs-attribute">Full</span> Name:<br>                  <span class="hljs-attribute">URI</span>:http://crl<span class="hljs-number">3</span>.digicert.com/ssca-sha<span class="hljs-number">2</span>-g<span class="hljs-number">6</span>.crl<br><br>                <span class="hljs-attribute">Full</span> Name:<br>                  <span class="hljs-attribute">URI</span>:http://crl<span class="hljs-number">4</span>.digicert.com/ssca-sha<span class="hljs-number">2</span>-g<span class="hljs-number">6</span>.crl<br><br>            <span class="hljs-attribute">X509v3</span> Certificate Policies: <br>                <span class="hljs-attribute">Policy</span>: <span class="hljs-number">2.16.840.1</span>.<span class="hljs-number">114412</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br>                  <span class="hljs-attribute">CPS</span>: https://www.digicert.com/CPS<br>                <span class="hljs-attribute">Policy</span>: <span class="hljs-number">2.23.140.1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br><br>            <span class="hljs-attribute">Authority</span> Information Access: <br>                <span class="hljs-attribute">OCSP</span> - URI:http://ocsp.digicert.com<br>                <span class="hljs-attribute">CA</span> Issuers - URI:http://cacerts.digicert.com/DigiCertSHA<span class="hljs-number">2</span>SecureServerCA.crt<br><br>            <span class="hljs-attribute">X509v3</span> Basic Constraints: critical<br>                <span class="hljs-attribute">CA</span>:FALSE<br>    <span class="hljs-attribute">Signature</span> Algorithm: sha<span class="hljs-number">256</span>WithRSAEncryption<br>         <span class="hljs-attribute">81</span>:f<span class="hljs-number">9</span>:b<span class="hljs-number">8</span>:e<span class="hljs-number">6</span>:ae:ee:e<span class="hljs-number">2</span>:<span class="hljs-number">89</span>:<span class="hljs-number">12</span>:<span class="hljs-number">8</span>d:d<span class="hljs-number">4</span>:d<span class="hljs-number">0</span>:<span class="hljs-number">6</span>c:c<span class="hljs-number">0</span>:<span class="hljs-number">04</span>:<span class="hljs-number">45</span>:f<span class="hljs-number">2</span>:<span class="hljs-number">9</span>e:<br>         <span class="hljs-attribute">5b</span>:<span class="hljs-number">38</span>:<span class="hljs-number">67</span>:ea:<span class="hljs-number">12</span>:f<span class="hljs-number">8</span>:<span class="hljs-number">0</span>f:<span class="hljs-number">50</span>:<span class="hljs-number">2</span>f:<span class="hljs-number">27</span>:<span class="hljs-number">77</span>:ab:<span class="hljs-number">45</span>:<span class="hljs-number">79</span>:<span class="hljs-number">31</span>:<span class="hljs-number">4</span>c:<span class="hljs-number">16</span>:cc:<br>         <span class="hljs-attribute">2f</span>:<span class="hljs-number">58</span>:<span class="hljs-number">9</span>b:<span class="hljs-number">7</span>c:<span class="hljs-number">11</span>:<span class="hljs-number">43</span>:a<span class="hljs-number">7</span>:<span class="hljs-number">88</span>:c<span class="hljs-number">3</span>:<span class="hljs-number">6</span>e:ce:b<span class="hljs-number">0</span>:<span class="hljs-number">89</span>:fb:e<span class="hljs-number">4</span>:c<span class="hljs-number">1</span>:ac:<span class="hljs-number">8</span>b:<br>         <span class="hljs-attribute">d3</span>:ae:d<span class="hljs-number">0</span>:ee:<span class="hljs-number">3</span>c:cb:<span class="hljs-number">33</span>:<span class="hljs-number">54</span>:<span class="hljs-number">03</span>:<span class="hljs-number">0</span>c:aa:<span class="hljs-number">4</span>f:<span class="hljs-number">6</span>a:<span class="hljs-number">23</span>:<span class="hljs-number">02</span>:<span class="hljs-number">58</span>:e<span class="hljs-number">5</span>:ed:<br>         <span class="hljs-attribute">55</span>:<span class="hljs-number">16</span>:<span class="hljs-number">1</span>a:d<span class="hljs-number">3</span>:a<span class="hljs-number">8</span>:<span class="hljs-number">95</span>:<span class="hljs-number">1</span>e:<span class="hljs-number">0</span>a:<span class="hljs-number">6</span>d:f<span class="hljs-number">9</span>:<span class="hljs-number">49</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span>:<span class="hljs-number">02</span>:<span class="hljs-number">9</span>b:<span class="hljs-number">19</span>:fb:<span class="hljs-number">22</span>:<br>         <span class="hljs-attribute">e2</span>:b<span class="hljs-number">1</span>:<span class="hljs-number">8</span>f:<span class="hljs-number">1</span>c:<span class="hljs-number">22</span>:ac:<span class="hljs-number">08</span>:<span class="hljs-number">76</span>:<span class="hljs-number">3</span>f:fd:<span class="hljs-number">4</span>f:d<span class="hljs-number">4</span>:<span class="hljs-number">7</span>e:<span class="hljs-number">57</span>:<span class="hljs-number">17</span>:<span class="hljs-number">93</span>:<span class="hljs-number">2</span>c:<span class="hljs-number">80</span>:<br>         <span class="hljs-attribute">b0</span>:<span class="hljs-number">0</span>c:ff:d<span class="hljs-number">5</span>:c<span class="hljs-number">9</span>:bb:b<span class="hljs-number">2</span>:bb:fc:<span class="hljs-number">95</span>:<span class="hljs-number">61</span>:<span class="hljs-number">2</span>c:e<span class="hljs-number">9</span>:<span class="hljs-number">94</span>:f<span class="hljs-number">9</span>:e<span class="hljs-number">2</span>:e<span class="hljs-number">9</span>:<span class="hljs-number">45</span>:<br>         <span class="hljs-attribute">7c</span>:<span class="hljs-number">02</span>:<span class="hljs-number">64</span>:e<span class="hljs-number">1</span>:<span class="hljs-number">52</span>:a<span class="hljs-number">3</span>:<span class="hljs-number">8</span>b:fa:<span class="hljs-number">48</span>:<span class="hljs-number">8</span>c:<span class="hljs-number">9</span>b:<span class="hljs-number">5</span>a:bd:<span class="hljs-number">76</span>:f<span class="hljs-number">3</span>:<span class="hljs-number">91</span>:b<span class="hljs-number">0</span>:<span class="hljs-number">3</span>a:<br>         <span class="hljs-attribute">d9</span>:<span class="hljs-number">27</span>:<span class="hljs-number">6</span>c:b<span class="hljs-number">6</span>:<span class="hljs-number">35</span>:<span class="hljs-number">38</span>:ac:<span class="hljs-number">88</span>:bf:<span class="hljs-number">48</span>:<span class="hljs-number">9</span>e:<span class="hljs-number">19</span>:e<span class="hljs-number">3</span>:<span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">7</span>e:<span class="hljs-number">00</span>:d<span class="hljs-number">9</span>:<br>         <span class="hljs-attribute">e6</span>:<span class="hljs-number">2</span>f:bc:<span class="hljs-number">08</span>:<span class="hljs-number">0</span>a:c<span class="hljs-number">5</span>:<span class="hljs-number">37</span>:<span class="hljs-number">4</span>d:ed:<span class="hljs-number">4</span>d:<span class="hljs-number">14</span>:<span class="hljs-number">78</span>:d<span class="hljs-number">1</span>:<span class="hljs-number">94</span>:c<span class="hljs-number">3</span>:<span class="hljs-number">40</span>:<span class="hljs-number">6</span>a:<span class="hljs-number">95</span>:<br>         <span class="hljs-attribute">96</span>:<span class="hljs-number">91</span>:f<span class="hljs-number">6</span>:<span class="hljs-number">38</span>:<span class="hljs-number">2</span>e:e<span class="hljs-number">4</span>:<span class="hljs-number">63</span>:f<span class="hljs-number">7</span>:fd:f<span class="hljs-number">6</span>:fb:<span class="hljs-number">25</span>:a<span class="hljs-number">5</span>:<span class="hljs-number">1</span>c:b<span class="hljs-number">0</span>:<span class="hljs-number">5</span>a:<span class="hljs-number">29</span>:e<span class="hljs-number">3</span>:<br>         <span class="hljs-attribute">dd</span>:d<span class="hljs-number">7</span>:<span class="hljs-number">68</span>:<span class="hljs-number">97</span>:<span class="hljs-number">2</span>a:<span class="hljs-number">58</span>:<span class="hljs-number">26</span>:fb:a<span class="hljs-number">1</span>:<span class="hljs-number">18</span>:e<span class="hljs-number">7</span>:e<span class="hljs-number">3</span>:<span class="hljs-number">80</span>:<span class="hljs-number">94</span>:<span class="hljs-number">6</span>b:<span class="hljs-number">1</span>f:b<span class="hljs-number">0</span>:<span class="hljs-number">65</span>:<br>         <span class="hljs-attribute">a6</span>:<span class="hljs-number">65</span>:<span class="hljs-number">1</span>d:<span class="hljs-number">79</span>:<span class="hljs-number">8</span>f:d<span class="hljs-number">7</span>:<span class="hljs-number">1</span>a:<span class="hljs-number">3</span>a:<span class="hljs-number">7</span>b:<span class="hljs-number">7</span>a:<span class="hljs-number">3</span>c:db:a<span class="hljs-number">6</span>:<span class="hljs-number">60</span>:a<span class="hljs-number">9</span>:<span class="hljs-number">99</span>:de:<span class="hljs-number">57</span>:<br>         <span class="hljs-attribute">f5</span>:<span class="hljs-number">7</span>a:bc:<span class="hljs-number">4</span>d:<span class="hljs-number">05</span>:e<span class="hljs-number">3</span>:<span class="hljs-number">64</span>:e<span class="hljs-number">2</span>:a<span class="hljs-number">9</span>:<span class="hljs-number">6</span>f:a<span class="hljs-number">1</span>:<span class="hljs-number">64</span>:<span class="hljs-number">09</span>:<span class="hljs-number">6</span>f:a<span class="hljs-number">5</span>:<span class="hljs-number">51</span>:<span class="hljs-number">62</span>:a<span class="hljs-number">2</span>:<br>         <span class="hljs-attribute">da</span>:b<span class="hljs-number">3</span>:<span class="hljs-number">6</span>d:f<span class="hljs-number">3</span><br><br><br></code></pre></td></tr></table></figure><p>关于里面的字段解释,可以对照这个来看</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 证书版本号(Version)<br>版本号指明X.509证书的格式版本，现在的值可以为:<br><span class="hljs-code">    1) 0: v1</span><br><span class="hljs-code">    2) 1: v2</span><br><span class="hljs-code">    3) 2: v3</span><br><span class="hljs-code">也为将来的版本进行了预定义</span><br><span class="hljs-code"></span><br><span class="hljs-code">2. 证书序列号(Serial Number)</span><br><span class="hljs-code">序列号指定由CA分配给证书的唯一的&quot;数字型标识符&quot;。当证书被取消时，实际上是将此证书的序列号放入由CA签发的CRL中，</span><br><span class="hljs-code">这也是序列号唯一的原因。</span><br><span class="hljs-code"></span><br><span class="hljs-code">3. 签名算法标识符(Signature Algorithm)</span><br><span class="hljs-code">签名算法标识用来指定由CA签发证书时所使用的&quot;签名算法&quot;。算法标识符用来指定CA签发证书时所使用的:</span><br><span class="hljs-code">    1) 公开密钥算法</span><br><span class="hljs-code">    2) hash算法</span><br><span class="hljs-code">example: sha256WithRSAEncryption</span><br><span class="hljs-code">须向国际知名标准组织(如ISO)注册</span><br><span class="hljs-code"></span><br><span class="hljs-code">4. 签发机构名(Issuer)</span><br><span class="hljs-code">此域用来标识签发证书的CA的X.500 DN(DN-Distinguished Name)名字。包括:</span><br><span class="hljs-code">    1) 国家(C)</span><br><span class="hljs-code">    2) 省市(ST)</span><br><span class="hljs-code">    3) 地区(L)</span><br><span class="hljs-code">    4) 组织机构(O)</span><br><span class="hljs-code">    5) 单位部门(OU)</span><br><span class="hljs-code">    6) 通用名(CN)</span><br><span class="hljs-code">    7) 邮箱地址</span><br><span class="hljs-code"></span><br><span class="hljs-code">5. 有效期(Validity)</span><br><span class="hljs-code">指定证书的有效期，包括:</span><br><span class="hljs-code">    1) 证书开始生效的日期时间</span><br><span class="hljs-code">    2) 证书失效的日期和时间</span><br><span class="hljs-code">每次使用证书时，需要检查证书是否在有效期内。</span><br><span class="hljs-code"></span><br><span class="hljs-code">6. 证书用户名(Subject)</span><br><span class="hljs-code">指定证书持有者的X.500唯一名字。包括:</span><br><span class="hljs-code">    1) 国家(C)</span><br><span class="hljs-code">    2) 省市(ST)</span><br><span class="hljs-code">    3) 地区(L)</span><br><span class="hljs-code">    4) 组织机构(O)</span><br><span class="hljs-code">    5) 单位部门(OU)</span><br><span class="hljs-code">    6) 通用名(CN)</span><br><span class="hljs-code">    7) 邮箱地址</span><br><span class="hljs-code"></span><br><span class="hljs-code">7. 证书持有者公开密钥信息(Subject Public Key Info)</span><br><span class="hljs-code">证书持有者公开密钥信息域包含两个重要信息:</span><br><span class="hljs-code">    1) 证书持有者的公开密钥的值</span><br><span class="hljs-code">    2) 公开密钥使用的算法标识符。此标识符包含公开密钥算法和hash算法。</span><br><span class="hljs-code">8. 扩展项(extension)</span><br><span class="hljs-code">X.509 V3证书是在v2的基础上一标准形式或普通形式增加了扩展项，以使证书能够附带额外信息。标准扩展是指</span><br><span class="hljs-code">由X.509 V3版本定义的对V2版本增加的具有广泛应用前景的扩展项，任何人都可以向一些权威机构，如ISO，来</span><br><span class="hljs-code">注册一些其他扩展，如果这些扩展项应用广泛，也许以后会成为标准扩展项。</span><br><span class="hljs-code"></span><br><span class="hljs-code">9. 签发者唯一标识符(Issuer Unique Identifier)</span><br><span class="hljs-code">签发者唯一标识符在第2版加入证书定义中。此域用在当同一个X.500名字用于多个认证机构时，用一比特字符串</span><br><span class="hljs-code">来唯一标识签发者的X.500名字。可选。</span><br><span class="hljs-code"></span><br><span class="hljs-code">10. 证书持有者唯一标识符(Subject Unique Identifier)</span><br><span class="hljs-code">持有证书者唯一标识符在第2版的标准中加入X.509证书定义。此域用在当同一个X.500名字用于多个证书持有者时，</span><br><span class="hljs-code">用一比特字符串来唯一标识证书持有者的X.500名字。可选。</span><br><span class="hljs-code"></span><br><span class="hljs-code">11. 签名算法(Signature Algorithm)</span><br><span class="hljs-code">证书签发机构对证书上述内容的签名算法</span><br><span class="hljs-code">example: sha256WithRSAEncryption</span><br><span class="hljs-code"></span><br><span class="hljs-code">12. 签名值(Issuer&#x27;s Signature)</span><br><span class="hljs-code">证书签发机构对证书上述内容的签名值</span><br></code></pre></td></tr></table></figure><p>所以在X509Certificate封装过程中如何识别,就根据实际情况自行决定了.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-转换器</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><p>对象转换<br>当表达式返回一个对象时,将会从自动set,重命名set,自定义set中自动选择set方法,根据set方法的参数类型,强制转换为对应的类型.<br>在用ObservableMaps存放数据时比较方便,比如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;TextView<br>   android:<span class="hljs-attribute">text</span>=<span class="hljs-string">&#x27;@&#123;userMap[&quot;lastName&quot;]&#125;&#x27;</span><br>   android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>这里userMap返回一个对象,这个对象将会根据<code>setText(CharSequence)</code>方法进行强制类型转换.但是某些时候直接强制类型转换是不行的,此时开发者需要手动进行转换.</p><h4 id="自定义的转换器"><a href="#自定义的转换器" class="headerlink" title="自定义的转换器"></a>自定义的转换器</h4><p>下面这种情况:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;View<br>   android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;@&#123;isError ? @color/red : @color/white&#125;&quot;</span><br>   android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>此处background需要一个<code>Drawable</code>,但是实际上color是一个<code>integer</code>对象.当出现这种情况时,需要将int转换为<code>ColorDrawable</code>.这个转换是通过<code>BindConversion</code>注解的静态方法实现的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingConversion</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ColorDrawable <span class="hljs-title">convertColorToDrawable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> color)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorDrawable(color);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:转换只发生在set方法中,所以下面混合的类型是不允许的.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;View<br>   android:<span class="hljs-attribute">background</span>=<span class="hljs-string">&quot;@&#123;isError ? @drawable/error : @color/white&#125;&quot;</span><br>   android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="AndroidStudio对databind的支持"><a href="#AndroidStudio对databind的支持" class="headerlink" title="AndroidStudio对databind的支持"></a>AndroidStudio对databind的支持</h4><p>android studio支持较多的databind编辑器特性.目前有如下支持:</p><ul><li>语法高亮</li><li>语法错误提示</li><li>xml自动完成</li><li>快速跳转到类声明,快速查看文档</li></ul><p>注意:数组和泛型类型,比如Observable类,可能在没有错误时也显示错误.</p><p>你可以通过表达式中使用default属性来指定希望在预览窗口中看到的样式.比如下面这个例子中,预览窗口会显示PLACEHOLDER值作为TextView默认的文字:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;TextView android:<span class="hljs-attribute">layout_width</span>=”wrap_content”<br>   android:<span class="hljs-attribute">layout_height</span>=”wrap_content”<br>   android:<span class="hljs-attribute">text</span>=”@&#123;user.firstName, <span class="hljs-attribute">default</span>=PLACEHOLDER&#125;”/&gt;<br></code></pre></td></tr></table></figure><p>如果你希望更简单的在设计阶段显示显示你的默认值,也可以使用tools命名空间来指定.详细使用可以参考Designtime Layout Attributes.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-属性设置</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>当一个被绑定属性变更时,绑定类会自动调用通过表达式和view关联起来的set方法.databind框架通常会自动决定调用哪个方法去设置对应的值.</p><p><strong>自动的set方法</strong><br>对应每个属性,databind会尝试寻找这个属性对应的set方法.该方法和命名空间无关,仅仅和属性名本身有关.例如,TextView通过android:text属性指定的表达式,将会寻找名为setText(String)的方法.如果表达式返回值为int,databind将会寻找setText(int)方法.所以当心表达式的返回值,如果必要的话,最好进行一下转换.注意:databind不管view实际上是否有对应的属性.,都会尝试寻找setXXX方法.所以根据这种机制,你可以”创造”属性用于databind.例如support包中的DrawerLayout在xml中没有任何属性,但是在java代码中却有很多set方法.所以你可以使用自动set机制去使用它们.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">`&lt;android.support.v4.widget.DrawerLayout<br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>    app:<span class="hljs-attribute">scrimColor</span>=<span class="hljs-string">&quot;@&#123;@color/scrim&#125;&quot;</span><br>    app:<span class="hljs-attribute">drawerListener</span>=<span class="hljs-string">&quot;@&#123;fragment.drawerListener&#125;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><em>译者注:上面的例子中app:scrimColor=”@{@color/scrim}”等同于setScrimColor(getColor(R.color.scrim)),但是直接使用app:scrimColor=”#33ff0000”这样的会编译报错.所以需要使用表达式来对xml中的属性进行赋值,databing才会自动调用对应的set方法</em></p><h4 id="重命名set方法"><a href="#重命名set方法" class="headerlink" title="重命名set方法"></a>重命名set方法</h4><p>有些属性的set方法并不完全和属性名称对应.对于这些方法,需要通过一个叫BindingMethods的注解来进行方法关联.每一个方法都要使用这个注解来封装属性和对应方法名.例如,<code>android:tint</code>属性实际上和<code>setImageTintList</code>关联了,而并非setTint.<br><em>译者注:参考databind源码:android.databinding.adapters.ImageViewBindingAdapter</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingMethods(&#123;</span><br><span class="hljs-meta">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span><br><span class="hljs-meta">                      attribute = &quot;android:tint&quot;,</span><br><span class="hljs-meta">                      method = &quot;setImageTintList&quot;),</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>对于开发者而言,并不需要进行这样的重命名.android系统已经实现了这样的转换.</p><p><em>译者注:为什么有时候是app:有时候是android:,前者自动set方法仅仅是根据属性名自动寻找对应的set方法,是无视namespace前缀的.但是后者由自带的绑定类进行了重命名,会转换为指定的set方法.</em></p><h4 id="自定义的set方法"><a href="#自定义的set方法" class="headerlink" title="自定义的set方法"></a>自定义的set方法</h4><p>有些属性需要根据代码逻辑进行自定义绑定.例如并没有一个方法对应android:paddingLeft属性,实际上存在的方法是<code>setPadding(left, top, right, bottom)</code>.这里我们可以使用一个静态的绑定方法,使用BindAdapter注解来帮助开发者来定义一个对应该属性需要被调用的方法.</p><p>在ViewBindingAdapter中已经内置了一些自定义的set方法.比如paddingLeft:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPaddingLeft</span><span class="hljs-params">(View view, <span class="hljs-keyword">int</span> padding)</span> </span>&#123;<br>   view.setPadding(padding,<br>                   view.getPaddingTop(),<br>                   view.getPaddingRight(),<br>                   view.getPaddingBottom());<br>&#125;<br></code></pre></td></tr></table></figure><p>BindingAdapter比较适合用于一些拥有自定义属性的情形.例如,你可以通过这种方式在子线程中加载图片.<br><em>当命名冲突时,开发者声明的bind adapter方法会覆盖掉默认的</em><br>你还可以给adapter定义多个参数用于接收:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(&#123;“bind:imageUrl”, “bind:error”&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(ImageView view, String url, Drawable error)</span> </span>&#123;<br>   Picasso.with(view.getContext()).load(url).error(error).into(view);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">app:imageUrl</span>=<span class="hljs-string">”@</span></span></span><span class="hljs-template-variable">&#123;venue.imageUrl&#125;</span><span class="xml"><span class="hljs-tag">”</span></span><br><span class="xml">app:error=”@</span><span class="hljs-template-variable">&#123;@drawable/venueError&#125;</span><span class="xml">”/&gt;</span><br></code></pre></td></tr></table></figure><p>如果bimageUrl和error同时设置在这个ImageView上面,并且值类型匹配,上面这个adapter的loadimage方法将会被调用.</p><p>上面这种写法默认是需要两个参数同时设置.如果仅设置了其中之一,会在编译阶段报错.或者可以采用下面这种写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(value = &#123;&quot;imageUrl&quot;, &quot;error&quot;&#125;, requireAll = false)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(ImageView view, String img, String error)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;loadImage:&quot;</span> + img + <span class="hljs-string">&quot;:&quot;</span> + error);<br>    &#125;<br></code></pre></td></tr></table></figure><p>将requireAll的默认值修改为false.就可以在xml中任意配置,未配置的会返回该参数类型的默认值.<br>自定义的namespace在匹配时会忽略.如上面的例子<br>你可以直接使用android命名空间.</p><p>bind adapter可以在执行方法时获取旧的值,如果你定义的方法参数中有旧的值,那你必须把旧值放在参数列表前面,新值放在参数列表后面,binddata会自动识别是否有旧值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(“android:paddingLeft”)</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPaddingLeft</span><span class="hljs-params">(View view, <span class="hljs-keyword">int</span> oldPadding, <span class="hljs-keyword">int</span> newPadding)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (oldPadding != newPadding) &#123; <br>view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>有时候参数可能是接口实现类.比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(“android:onLayoutChange”)</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnLayoutChangeListener</span><span class="hljs-params">(View view, View.OnLayoutChangeListener oldValue, View.OnLayoutChangeListener newValue)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.HONEYCOMB) &#123;<br><span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span>) &#123; <br>view.removeOnLayoutChangeListener(oldValue); &#125;<br><span class="hljs-keyword">if</span> (newValue != <span class="hljs-keyword">null</span>) &#123; <br>view.addOnLayoutChangeListener(newValue); &#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>译者注:值发生变更依然还是根据表达式中引用的变量发生改变,然后调用notifyPropertyChanged引起.BindAdapter只是定义了xml中key和对应的model属性如何关联起来.</p><p>当表达式中监听的方法是某个listener方法之一时,需要将该listener下每个方法进行单独定义.比如View.OnAttachStateChangeListener有两个方法:onViewAttachedToWindow()和onViewDetachedFromWindow(),我们必须创建两个接口来区分和捕获它们.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnViewDetachedFromWindow</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(View v)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnViewAttachedToWindow</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(View v)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为改变其中一个会影响到另一个(在java代码中,这两个监听是通过同一个方法一起设置到某个view上面),所以我们要定义3个绑定方法,对应只定义一个和同时定义两个的情况.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter(“android:onViewAttachedToWindow”)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setListener</span><span class="hljs-params">(View view, OnViewAttachedToWindow attached)</span> </span>&#123;<br>setListener(view, <span class="hljs-keyword">null</span>, attached);<br>&#125;<br><br><span class="hljs-meta">@BindingAdapter(“android:onViewDetachedFromWindow”)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setListener</span><span class="hljs-params">(View view, OnViewDetachedFromWindow detached)</span> </span>&#123;<br>setListener(view, detached, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@BindingAdapter(&#123;“android:onViewDetachedFromWindow”, “android:onViewAttachedToWindow”&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setListener</span><span class="hljs-params">(View view, <span class="hljs-keyword">final</span> OnViewDetachedFromWindow detach,<span class="hljs-keyword">final</span> OnViewAttachedToWindow attach)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;<br><span class="hljs-keyword">final</span> OnAttachStateChangeListener newListener;<br><span class="hljs-keyword">if</span> (detach == <span class="hljs-keyword">null</span> &amp;&amp; attach == <span class="hljs-keyword">null</span>) &#123;<br>newListener = <span class="hljs-keyword">null</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>newListener = <span class="hljs-keyword">new</span> OnAttachStateChangeListener() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (attach != <span class="hljs-keyword">null</span>) &#123;<br>attach.onViewAttachedToWindow(v);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (detach != <span class="hljs-keyword">null</span>) &#123;<br>detach.onViewDetachedFromWindow(v);<br>&#125;<br>&#125;<br> &#125;;<br>&#125;<br><span class="hljs-keyword">final</span> OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,newListener, R.id.onAttachStateChangeListener);<br><span class="hljs-keyword">if</span> (oldListener != <span class="hljs-keyword">null</span>) &#123;<br>view.removeOnAttachStateChangeListener(oldListener);<br>&#125;<br><span class="hljs-keyword">if</span> (newListener != <span class="hljs-keyword">null</span>) &#123;<br>view.addOnAttachStateChangeListener(newListener);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子看起来比通常的情况要复杂,这是因为有些listener需要使用add/remove而并非简单的set方法.比如View.OnAttachStateChangeListener.工具类android.databinding.adapters.ListenerUtil可以帮助开发者有效的管理view上面的listener情况.</p><p>通过@TargetApi(VERSION_CODES.HONEYCOMB_MR1)注解,databind会自动根据当前运行sdk版本来决定要不要生成对应的代码.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-生成绑定</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E7%94%9F%E6%88%90%E7%BB%91%E5%AE%9A/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E7%94%9F%E6%88%90%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="生成绑定"><a href="#生成绑定" class="headerlink" title="生成绑定"></a>生成绑定</h3><p>自动生成的绑定类将layout中定义的变量和view关联起来.根据前面的讨论,绑定类的名字和所在的包名是可以定制的.共同点是:所有的绑定类都继承于ViewDataBinding.</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>绑定关系应该在解析完布局之后马上创建,防止后续的代码影响到布局结构.这里有几种方法可以对一个layout建立绑定关系,最常用的是使用绑定类的静态方法.inflate方法可以同时完成view层级解析和绑定关系建立.(译者注:相对于反复findviewbyid,这种一次解析完成映射可以节省不少时间)<br>下面是两个简单的绑定示例,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);<br>MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>如果你的view已经inflate出来了.仅仅需要绑定.可以这样做:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);<br></code></pre></td></tr></table></figure><p>有时候你可能想写一些工具类方法,即并不知道需要绑定类的类型,你可以使用DataBindingUtils:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId,<br>    parent, attachToParent);<br>ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);<br></code></pre></td></tr></table></figure><h4 id="组件id"><a href="#组件id" class="headerlink" title="组件id"></a>组件id</h4><p>针对layout中指定了id的view组件,会对应生成public final的变量.绑定过程解析一次不举文件,找出带有id的组件.这个比多次findViewById要快很多.例如:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">   &lt;LinearLayout</span><br><span class="xml">       android:orientation=&quot;vertical&quot;</span><br><span class="xml">       android:layout_width=&quot;match_parent&quot;</span><br><span class="xml">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span></span><br><span class="xml">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="xml">           android:text=&quot;@</span><span class="hljs-template-variable">&#123;user.firstName&#125;</span><span class="xml">&quot;</span><br><span class="xml">   android:id=&quot;@+id/firstName&quot;/&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span></span><br><span class="xml">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="xml">           android:text=&quot;@</span><span class="hljs-template-variable">&#123;user.lastName&#125;</span><span class="xml">&quot;</span><br><span class="xml">  android:id=&quot;@+id/lastName&quot;/&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>会在绑定类中生成这两个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TextView firstName;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TextView lastName;<br></code></pre></td></tr></table></figure><p>不指定id也可以使用databind,但是如果后期需要访问这个view的话,还是需要指定id的.</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>每个变量都会生成get/set方法.</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-built_in">data</span>&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;android.graphics.drawable.Drawable&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;user&quot;</span>  <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;Drawable&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;note&quot;</span>  <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;<br>&lt;/<span class="hljs-built_in">data</span>&gt;<br></code></pre></td></tr></table></figure><p>上面的layout会在bind类中生成以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> com.example.<span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(com.example.User user)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Drawable <span class="hljs-title">getImage</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImage</span><span class="hljs-params">(Drawable image)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getNote</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNote</span><span class="hljs-params">(String note)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="ViewStubs"><a href="#ViewStubs" class="headerlink" title="ViewStubs"></a>ViewStubs</h4><p>ViewStubs和普通view有点不同.它们一开始是不可见的,而且并不会解析到view层级中.只有需要显示的时候,才会替换原有的布局,并显示出自身.<br>因为ViewStub最终会从view层级中移除,那么绑定类中对应的属性应该也可以及时回收.<br>但是因为view是final类型的,所以用ViewStubProxy来取代原本的ViewStub,让开发者可以访问这个ViewStub,并且当对应的view显示时,可以访问到那个view.<br>当解析另外一个布局文件的时候,绑定对象也应该和新的布局关联起来.因此,ViewStubProxy需要监听ViewStub的 OnInflateListener回调接口来建立绑定关系.开发者可以在ViewStubProxy上设置一个OnInflateListener ,当绑定建立的时候,开发者可以收到回调函数.<br><em>(译者注:ViewStub用得实在不多,此处没有试验)</em></p><h4 id="绑定进阶"><a href="#绑定进阶" class="headerlink" title="绑定进阶"></a>绑定进阶</h4><p><strong>动态数据模型</strong><br>有时候,并不能知道具体绑定的数据模型.比如在使用RecyclerView.Adapter这样的适配器时,只有在onBindViewHolder中才能知道对应的数据模型.<br>这种情况下,假设adapter的layout中都有一个item变量.这样你可以使用setVarible方法来将数据模型和item绑定在一起.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(BindingHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>   <span class="hljs-keyword">final</span> T item = mItems.get(position);<br>   holder.getBinding().setVariable(BR.item, item);<br>   holder.getBinding().executePendingBindings();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>立即刷新</strong><br>当数据模型变化时,绑定关系会在下一个周期中刷新页面,这可能会有一点延迟.如果想要强制刷新,可以使用executePendingBindings)方法.</p><p><strong>后台线程</strong><br>只要数据模型不是一个集合,你就可以在任意子线程中进行修改.databind会通过保存到本地来帮你解决同步问题.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-数据模型</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>任意POJO(简单java对象)都可以用于数据绑定.但是默认情况下,修改一个POJO的属性,并不会引发UI更新.databind真正的威力在于可以给予数据模型在数据发生变化时请求UI更新的能力.这里有3中不同的数据变更通知机制.<br>Observable objects, observable fields, 和observable collections.</p><p><strong>Observable objects</strong><br>实现了Observable接口的类实例会允许bind过程中给它添加一个listener,用来监听这个实例属性的变化.</p><p>Observable接口定义了添加和移除listener的机制,但是开发者关心的只是数据变化发起的通知.为了方便开发者,基类BaseObservable被创建,用来自动完成listener添加机制.但是实现方依然有责任在数据发生变化时,发出通知.这里可以通过添加一个Bindable的注解在get方法上,并在set方法中来发出通知.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseObservable</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> String firstName;<br>   <span class="hljs-keyword">private</span> String lastName;<br>   <span class="hljs-meta">@Bindable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName;<br>   &#125;<br>   <span class="hljs-meta">@Bindable</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lastName;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(String firstName)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.firstName = firstName;<br>       notifyPropertyChanged(BR.firstName);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(String lastName)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.lastName = lastName;<br>       notifyPropertyChanged(BR.lastName);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>译者注,不写get/set方法,直接把注解加载成员变量上面也是可以的.</em><br>编译过程中,会在module package中生成BR类,Bindable注解在这个过程中会在BR类中生成一个变量.<br>如果您的数据类无法修改，则可以使用 PropertyChangeRegistry 来保存和通知改变事件。<em>(此处不太懂)</em></p><h4 id="ObservableFields"><a href="#ObservableFields" class="headerlink" title="ObservableFields"></a>ObservableFields</h4><p>直接继承BaseObservable类可能有点麻烦.如果你的类只有一小部分属性需要变化并通知,你可以使用ObervableField及其相关类:ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable.<br>ObervableFields是一个自身继承BaseObservable的对象,内部封装了一个基本对象,访问时并不会涉及封包解包操作.使用时,在数据对象中创建一个public final的属性即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ObservableField&amp;lt;String&amp;gt; firstName =<br>       <span class="hljs-keyword">new</span> ObservableField&amp;lt;&amp;gt;();<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ObservableField&amp;lt;String&amp;gt; lastName =<br>       <span class="hljs-keyword">new</span> ObservableField&amp;lt;&amp;gt;();<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ObservableInt age = <span class="hljs-keyword">new</span> ObservableInt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样,操作属性的时候,使用get/set方法即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">user.firstName.set(<span class="hljs-string">&quot;Google&quot;</span>);<br><span class="hljs-keyword">int</span> age = user.age.get();<br></code></pre></td></tr></table></figure><h4 id="Observable-Collections"><a href="#Observable-Collections" class="headerlink" title="Observable Collections"></a>Observable Collections</h4><p>有的应用中可能需要更加灵活的数据结构来存储数据.ObservableCollections支持使用key或者下标来访问这些数据.<br>当key为对象时,比如String,可以使用ObservableArrayMap:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ObservableArrayMap&amp;lt;String, Object&amp;gt; user = <span class="hljs-keyword">new</span> ObservableArrayMap&amp;lt;&amp;gt;();<br>user.put(<span class="hljs-string">&quot;firstName&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>);<br>user.put(<span class="hljs-string">&quot;lastName&quot;</span>, <span class="hljs-string">&quot;Inc.&quot;</span>);<br>user.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">17</span>);<br></code></pre></td></tr></table></figure><p>然后在layout中可以通过key来访问数据</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.databinding.ObservableMap&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ObservableMap&lt;String, Object&gt;&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><br><span class="xml">&lt;TextView</span><br><span class="xml">   android:text=&#x27;@</span><span class="hljs-template-variable">&#123;user[&quot;lastName&quot;]&#125;</span><span class="xml">&#x27;</span><br><span class="xml">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="xml">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="xml">&lt;TextView</span><br><span class="xml">   android:text=&#x27;@</span><span class="hljs-template-variable">&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;</span><span class="xml">&#x27;</span><br><span class="xml">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="xml">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></code></pre></td></tr></table></figure><p>当key为int时.可以用ObservableArrayList,然后通过下标来访问数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ObservableArrayList&lt;Object&gt; user = <span class="hljs-keyword">new</span> ObservableArrayList&lt;&gt;();<br>user.add(<span class="hljs-string">&quot;Google&quot;</span>);<br>user.add(<span class="hljs-string">&quot;Inc.&quot;</span>);<br>user.add(<span class="hljs-number">17</span>);<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”android.databinding.ObservableList”/</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”com.example.my.app.Fields”/</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”user”</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”ObservableList</span>&lt;<span class="hljs-attr">Object</span>&gt;</span>”/&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><br><span class="xml">&lt;TextView</span><br><span class="xml">android:text=’@</span><span class="hljs-template-variable">&#123;user[Fields.LAST_NAME]&#125;</span><span class="xml">’</span><br><span class="xml">android:layout_width=”wrap_content”</span><br><span class="xml">android:layout_height=”wrap_content”/&gt;</span><br><span class="xml">&lt;TextView</span><br><span class="xml">android:text=’@</span><span class="hljs-template-variable">&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;</span><span class="xml">’</span><br><span class="xml">android:layout_width=”wrap_content”</span><br><span class="xml">android:layout_height=”wrap_content”/&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-layout编码</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-layout%E7%BC%96%E7%A0%81/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-layout%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Layout编码介绍"><a href="#Layout编码介绍" class="headerlink" title="Layout编码介绍"></a>Layout编码介绍</h3><h4 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h4><p>你可以在data元素内部使用任意数量的import元素.类似于java中的import,这样可以很方便的导入其他的类.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;android.view.View&quot;</span><br></code></pre></td></tr></table></figure><p>现在你可以在bind表达式中使用View的属性了.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;TextView<br>   android:<span class="hljs-attribute">text</span>=<span class="hljs-string">&quot;@&#123;user.lastName&#125;&quot;</span><br>   android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">visibility</span>=<span class="hljs-string">&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>如果class名称有冲突,你需要给其中一个起个别名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">&lt;<span class="hljs-keyword">import</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;android.view.View&quot;</span>/&gt;<br>&lt;<span class="hljs-keyword">import</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;com.example.real.estate.View&quot;</span><br>        alias=<span class="hljs-string">&quot;Vista&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>现在layout文件中,Vista可以用来代表com.example.real.estate.View,而View则还是表示android.view.View.<br>导入的类可以用于变量或者表达式中.</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-built_in">data</span>&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;java.util.List&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;userList&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;List&amp;lt;User&amp;gt;&quot;</span>/&gt;<br>&lt;/<span class="hljs-built_in">data</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意:AndroidStudio目前还不支持使用import类时变量名称的自动完成.这不影响整个项目的正常编译,不过你可能需要花一些时间在手写完整变量名称上面.</p></blockquote><p><em>译者注:截止20170315,android studio2.3中已经可以自动完成变量名了.</em></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;TextView<br>   android:<span class="hljs-attribute">text</span>=<span class="hljs-string">&quot;@&#123;((User)(user.connection)).lastName&#125;&quot;</span><br>   android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>   android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>import类型同样可以用于在表达式中调用静态方法</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.MyStringUtils&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><br><span class="xml">&lt;TextView</span><br><span class="xml">   android:text=&quot;@</span><span class="hljs-template-variable">&#123;MyStringUtils.capitalize(user.lastName)&#125;</span><span class="xml">&quot;</span><br><span class="xml">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="xml">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></code></pre></td></tr></table></figure><p>跟java一样,java.lang.*是默认导入的.</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>data元素中可以放入任意数量的变量.每个变量描述了即将绑定于layout中的一个对象类型.</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-built_in">data</span>&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;android.graphics.drawable.Drawable&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;user&quot;</span>  <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;Drawable&quot;</span>/&gt;<br>    &lt;<span class="hljs-built_in">variable</span> name=<span class="hljs-string">&quot;note&quot;</span>  <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;<br>&lt;/<span class="hljs-built_in">data</span>&gt;<br></code></pre></td></tr></table></figure><p>变量类型会在编译期间检测,所以如果一个变量实现了Observable或者是一个observable容器,它将会反射为对应的类型.否则将会被忽略.</p><p>如果针对不同的情况配置了不同的layout文件(比如横屏和竖屏),变量将会被合并.所以你必须保证这些layout文件之间不会有冲突.</p><p>针对layout文件中变量使用到的属性,编译过程中自动生成的绑定类将会对这些属性生成get/set方法,属性的默认值遵循java的定义,引用返回null,int返回0.<br>如果你自己已经定义了get方法,会以get方法返回的为准.</p><p>特别的,一个名为context的变量将会自动生成,以便于在表达式中使用,这个context实际上就是来源于当前view的getContext方法.如果你在layout中手动定义了一个变量名字也叫context,那么这个默认的context会被覆盖.</p><h4 id="自定义绑定类的名称"><a href="#自定义绑定类的名称" class="headerlink" title="自定义绑定类的名称"></a>自定义绑定类的名称</h4><p>默认情况下,绑定类会根据layout文件名执行一定的规则来生成:首字母大写,移除下划线,并把每个下划线后面的第一个字母大写,最后加上后缀Binding.这个类会被放置在module的databinding包里面(build/generatd/source/apt/debug/xxxxx包名/databinding).<br>例如一个名为contact_item.xml的layout文件,将会生成一个名为ContactItemBinding的类.如果module包名是com.example.my.app,那么这个类将会被放置在com.example.my.app.databinding下面.</p><p>使用data元素的class属性,你可以定义绑定类的名字.比如</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword">data</span> class=&quot;<span class="hljs-type">ContactItem</span>&quot;&gt;</span><br>    ...<br>&lt;/<span class="hljs-class"><span class="hljs-keyword">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样会将原本自动生成的绑定类名修改为ContactItem这个名字.但是放置位置不变.还是在module包名/databinding下面.如果需要放在包名下的别的目录.可以这样,使用.前缀是最简单的.</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword">data</span> class=&quot;.<span class="hljs-type">ContactItem</span>&quot;&gt;</span><br>    ...<br>&lt;/<span class="hljs-class"><span class="hljs-keyword">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样ContactItem类会直接放在包名下面.或者你可以直接指定任意包名:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword">data</span> class=&quot;com.example.<span class="hljs-type">ContactItem</span>&quot;&gt;</span><br>    ...<br>&lt;/<span class="hljs-class"><span class="hljs-keyword">data</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>通过定义application的命名空间和变量的名字,变量可以传递给使用included方式引入的layout文件.</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="xml">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">   &lt;LinearLayout</span><br><span class="xml">       android:orientation=&quot;vertical&quot;</span><br><span class="xml">       android:layout_width=&quot;match_parent&quot;</span><br><span class="xml">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/name&quot;</span></span></span><br><span class="xml">           bind:user=&quot;@</span><span class="hljs-template-variable">&#123;user&#125;</span><span class="xml">&quot;/&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/contact&quot;</span></span></span><br><span class="xml">           bind:user=&quot;@</span><span class="hljs-template-variable">&#123;user&#125;</span><span class="xml">&quot;/&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里要求必须在name.xml和contact.xml中都定义了user变量.</p><blockquote><p>注意:databind框架并不支持在merge标签中直接引入一个layout.</p></blockquote><p>比如下面这种是不支持的:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="xml">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">merge</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/name&quot;</span></span></span><br><span class="xml">           bind:user=&quot;@</span><span class="hljs-template-variable">&#123;user&#125;</span><span class="xml">&quot;/&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/contact&quot;</span></span></span><br><span class="xml">           bind:user=&quot;@</span><span class="hljs-template-variable">&#123;user&#125;</span><span class="xml">&quot;/&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="表达式语法"><a href="#表达式语法" class="headerlink" title="表达式语法"></a>表达式语法</h4><p><strong>常见的支持语法</strong></p><p>表达式语法很多方面类似于java,下面这些用法是一样的:<br>数学运算符 + - / * %<br>字符串拼接 +<br>逻辑运算 &amp;&amp; ||<br>位运算 &amp; | ^<br>一元运算符 + - ! ~<br>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;<br>比较运算 == &gt; &lt; &gt;= &lt;=<br>类型判断 instanceof<br>括号 ()<br>常量 字符串,数字<br>强制类型转换 cast<br>方法调用<br>属性访问<br>数组元素访问<br>三元运算符 ?:</p><p>举个栗子:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">android:</span>text=<span class="hljs-string">&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="hljs-attr">android:</span>visibility=<span class="hljs-string">&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="hljs-attr">android:</span>transitionName=<span class="hljs-string">&#x27;@&#123;&quot;image_&quot; + id&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>不支持的运算符<br>下面这些是java中常用,但是目前表达式中不支持的</p><p>this<br>super<br>new<br>Explicit generic invocation(我也不知道这是什么鬼)</p><p>合并的判空运算符<br>使用??运算符,优先选择左边的,如果左边的为null,使用右边的.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">android:<span class="hljs-built_in">text</span>=<span class="hljs-string">&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面的等价于</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">android:text=&quot;@&#123;user.displayName</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">user.displayName :</span> <span class="hljs-string">user.lastName&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>自动避免空指针异常<br>生成的绑定类会自动避免空指针异常.比如在这个表达式@{user.name}中,如果user是null,user.name将会定义为null.同样如果你使用的是user.age,age是一个`int``类型,将会得到默认值0.</p><p>集合<br>通常的集合:arrays, lists, sparse lists, maps,都可以使用[]来方便的访问其内容.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;data&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=&quot;android.util.SparseArray&quot;/&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=&quot;java.util.Map&quot;/&gt;<br>    &lt;<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span>=&quot;java.util.List&quot;/&gt;<br>    &lt;variable <span class="hljs-type">name</span>=&quot;list&quot; <span class="hljs-keyword">type</span>=&quot;List&amp;lt;String&amp;gt;&quot;/&gt;<br>    &lt;variable <span class="hljs-type">name</span>=&quot;sparse&quot; <span class="hljs-keyword">type</span>=&quot;SparseArray&amp;lt;String&amp;gt;&quot;/&gt;<br>    &lt;variable <span class="hljs-type">name</span>=&quot;map&quot; <span class="hljs-keyword">type</span>=&quot;Map&amp;lt;String, String&amp;gt;&quot;/&gt;<br>    &lt;variable <span class="hljs-type">name</span>=&quot;index&quot; <span class="hljs-keyword">type</span>=&quot;int&quot;/&gt;<br>    &lt;variable <span class="hljs-type">name</span>=&quot;key&quot; <span class="hljs-keyword">type</span>=&quot;String&quot;/&gt;<br>&lt;/data&gt;<br><br><br>android:<span class="hljs-type">text</span>=&quot;@&#123;list[index]&#125;&quot;<br>android:<span class="hljs-type">text</span>=&quot;@&#123;sparse[index]&#125;&quot;<br>android:<span class="hljs-type">text</span>=&quot;@&#123;map[key]&#125;&quot;<br></code></pre></td></tr></table></figure><p>字符串常量<br>layout中使用单引号来来指定value,则可以在内部使用双引号.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">android:<span class="hljs-built_in">text</span>=&#x27;@&#123;map[<span class="hljs-string">&quot;firstName&quot;</span>]&#125;&#x27;<br></code></pre></td></tr></table></figure><p>反过来layout中使用双引号(默认),则内部可以使用单引号或者反引号</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">android:text=<span class="hljs-string">&quot;<span class="hljs-subst">@&#123;<span class="hljs-keyword">map</span>[<span class="hljs-string">`firstName`</span>]&#125;</span>&quot;</span><br>android:text=<span class="hljs-string">&quot;<span class="hljs-subst">@&#123;<span class="hljs-keyword">map</span>[<span class="hljs-string">&#x27;firstName&#x27;</span>]&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>资源<br>你可以像以前一样的语法来使用资源id.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">android:padding=<span class="hljs-string">&quot;<span class="hljs-subst">@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>FormatString也是可以用的.<em>(译者注:这里本来还有个plurals资源,不过用得实在太少了.)</em></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">android:text=”@&#123;@<span class="hljs-built_in">string</span>/name<span class="hljs-constructor">Format(<span class="hljs-params">firstName</span>, <span class="hljs-params">lastName</span>)</span>&#125;”<br></code></pre></td></tr></table></figure><p>部分资源需要使用修改过的名称:</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-事件处理</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>事件处理</strong><br>databind机制允许你使用表达式来处理来自于view的事件,比如onclick.<br>事件的名称和实际对应的listener方法名有关,有时间会有一些小变更.<br>例如onLongClickListener有一个方法onLongClick,所以对应的事件为android:onLongClick.这里有两种方式去处理一个事件:<br>方法引用:通过表达式,你可以将其指向与之参数匹配的listener方法.当一个表达式被确认指向某个方法的时候,databind框架会在一个listener中将方法引用和对应的data对象绑定起来,然后将这个listener设置给对应的view.如果表达式设置为null,databind框架将不会创建listener,并且使用空的listener来代替.<br><em>译者注:这可能影响到某些view的按下效果</em><br>listener绑定:你可以使用lambda表达式来进行事件分发,databind框架将总是会创建listener并设置给view,当事件发生的时候,listener会使用这个lambda表达式.</p><p><strong>方法引用</strong><br>事件可以直接指向某个方法,类似于android:onclick可以定义为activity的一个方法.<br>但是与view的onclick方法相比最主要的优势是,databind中这种表达式会在编译期间进行处理,所以如果对应的方法不存在或者参数不匹配,会导致编译过程中报错.</p><blockquote><p>方法引用和监听器绑定最主要的区别在于,实际的监听器实现是在data模型被绑定的时候,而并非是事件被触发的时候,如果你希望当事件发生的时候就能执行对应的代码,你应该使用listener绑定</p></blockquote><p>下面是一个普通的bind表达式示例,使用方法名称当做value值即可.假如你的data模型有这样一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlers</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClickFriend</span><span class="hljs-params">(View view)</span> </span>&#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后绑定表达式可以这样指派某个view的点击事件:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;handlers&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.Handlers&quot;</span>/&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.User&quot;</span>/&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">   &lt;LinearLayout</span><br><span class="xml">       android:orientation=&quot;vertical&quot;</span><br><span class="xml">       android:layout_width=&quot;match_parent&quot;</span><br><span class="xml">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span></span><br><span class="xml">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="xml">           android:text=&quot;@</span><span class="hljs-template-variable">&#123;user.firstName&#125;</span><span class="xml">&quot;</span><br><span class="xml">           android:onClick=&quot;@</span><span class="hljs-template-variable">&#123;handlers::onClickFriend&#125;</span><span class="xml">&quot;/&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>注意:表达式中定义的方法的参数必须保持和实际的listener中方法参数完全一样.</strong></p><p><strong>listener绑定</strong></p><p>listener绑定用来设置当事件发生时执行某些方法.跟方法引用有点像,但是它允许你使用更加随意的bind表达式.这个特性需要android gradle插件2.0版本以上.</p><p>在方法引用中,方法参数必须和listener的方法参数完全一样.但是在listener绑定中,你只需要保证返回值和listener方法一样即可(除非是void).例如,你可以定义这样一个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Presenter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveClick</span><span class="hljs-params">(Task task)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后你可以这样绑定一个点击事件</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;task&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.android.example.Task&quot;</span> /&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;presenter&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.android.example.Presenter&quot;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span></span><br><span class="xml">          android:onClick=&quot;@</span><span class="hljs-template-variable">&#123;() -&gt; presenter.onSaveClick(task)&#125;</span><span class="xml">&quot; /&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>listener被lambda表达式代替了,当你在表达式中使用这样的callback型语句时,databind框架会自动帮你生成对应的listener并且注册到事件上,当事件被触发时,对应的表达式将被执行.当表达式被执行的时候是线程安全的.</p><p>注意上面的例子,我们并没有像onclick(View)这样为onSaveClick方法定义一个View参数.listener绑定提供了两个选择用于参数定义:你可以忽略所有参数,或者列出所有参数.如果你列出了所有参数,你可以在表达式中使用它.比如上面的表达式可以写成这样:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>onClick=<span class="hljs-string">&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>或者如果你想在表达式中使用这个参数,你可以这么写</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>onClick=<span class="hljs-string">&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>你可以使用不止一个参数的lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Presenter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompletedChanged</span><span class="hljs-params">(Task task, <span class="hljs-keyword">boolean</span> completed)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;CheckBox android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:<span class="hljs-attribute">onCheckedChanged</span>=<span class="hljs-string">&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>如果事件对应方法返回类型不是void,你的表达式必须返回跟它一样的类型.例如,如果你想监听长按事件.你的表达式必须返回boolean类型的结果.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Presenter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(View view, Task task)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>onLongClick=<span class="hljs-string">&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>如果表达式遇到了空的实现,databind会返回默认的java基本类型对应的数据.引用会返回null,int会返回0,boolean会返回false.<br>如果你使用了条件判断,你可以使用void作为一个元素.</p><p><strong>避免使用复杂的listener</strong></p><p>listener表达式具有很强大的功能,可以让你的代码变得非常易读.但是从另一方面来说,复杂的表达式可能会让你的layout文件变得可读性和可维护性较差.你应该尽可能简单的将数据从UI传递到定义的方法中来,然后在方法中再去实现复杂的业务逻辑.<br>为了防止冲突,有些点击事件需要除了android:onClick以外的名字来定义,比如下面这些方法</p><p>Class           Listener                                           Setter Attribute<br>SearchView      setOnSearchClickListener(View.OnClickListener)     android:onSearchClick<br>ZoomControls    setOnZoomInClickListener(View.OnClickListener)     android:onZoomIn<br>ZoomControls    setOnZoomOutClickListener(View.OnClickListener)    android:onZoomOut</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBindingLibrary译文-前言+目录</title>
    <link href="/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E5%89%8D%E8%A8%80-%E7%9B%AE%E5%BD%95/"/>
    <url>/2018/02/03/DataBindingLibrary%E8%AF%91%E6%96%87-%E5%89%8D%E8%A8%80-%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>由于项目的技术债务太多.一直没有时间转向真正的mvvm,趁着最近进入全速开发期,有一些空闲,好好把mvvm整一整.</p><p>首先从官方文档开始吧,一边阅读一边记录,把翻译内容记录下来,既增加自身理解,又方便后人.</p><p><strong>DataBindingLibrary</strong><br>这篇文档介绍了如何使用databind框架去编写内容更丰富的layout,并且尽量减少那些存在于业务逻辑和layout文件之间的胶水代码.译者注:比如MVP中的P<br>由于databind是一个支持组件,所以它具备了扩展性和一致性.你可以在android 2.1以上的版本中使用它.<br>同时你还需要andoid的gradle插件1.5版本以上.这里可以看到如何更新gradle插件.</p><p>[事件处理]</p><p>[layout编码]</p><p>[数据模型]</p><p>[生成绑定]</p><p>[属性设置]</p><p>[转换器]</p><p>第一遍阅读,翻译得比较渣.待使用过程中逐步完善吧.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>由一道算法题引出的基本类型封装类问题</title>
    <link href="/2018/02/03/%E7%94%B1%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%87%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2018/02/03/%E7%94%B1%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E5%BC%95%E5%87%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>先看这道题目.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;before a=&quot;</span> + a + <span class="hljs-string">&quot;,b=&quot;</span> + b);<br>        swap(a, b);<br>        System.out.println(<span class="hljs-string">&quot;after a=&quot;</span> + a + <span class="hljs-string">&quot;,b=&quot;</span> + b);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Integer i1, Integer i2)</span> </span>&#123;<br>        <span class="hljs-comment">//编程实现两个数字进行交换</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法传递的是引用,Integer是java中对于int基本类型的封装类.这个类貌似并没有setXXX这样的方法来改变内部的某个值.</p><p>好吧.阅读Integer源码得知,其内部有个私有的value变量.于是反射修改之.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Integer i1, Integer i2)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field f = Integer.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            f.set(i1, <span class="hljs-number">20</span>);<br>            f.set(i2, <span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行一下:</p><blockquote><p>before a=10,b=20<br>after a=20,b=20</p></blockquote><p>a修改成功了.b却没修改成功.百思不得其解啊.</p><p>这里发现两个问题:</p><p>1.反射时,set参数接收的是Object类型,此处传入int,会将基本类型转换为包装类型即Integer.(很重要)</p><p>2.第二个参数在调用处传的是10,此处变成了一个intvalue为20的Integer对象.(???)</p><p>这里有一个知识点—-Integer中的IntegerCache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125;<br>            high = h;<br><br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &amp;lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单来说,为了防止在int类型自动装箱拆箱过程中频繁的new Integer(),Interger内部使用IntegerCache类建立了一个默认255长度的缓存池.初始化时就会生成-128~127之间对应的所有Integer对象.</p><p>什么时候使用这个缓存呢?调用Integer.valueOf()方法的时候.</p><p>什么时候调用这个方法?Integer i = 10;这样写,系统自动装箱的时候.</p><p>而真正的new Integer()方法则才是创建一个新的对象,并将内部的value值赋值为构造方法传入的值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br></code></pre></td></tr></table></figure><p>那么现在重新分析一下前面的代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>//从缓存中找到指定位置的两个Integer对象,a,b分别指向这两个对象.</p><p>//为方便后面描述,暂忽略负数部分.假定a指向第10个位置,b指向第20个位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Field f = Integer.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>f.setAccessible(<span class="hljs-keyword">true</span>);<br>f.set(i1, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>//此处将第10个位置的Integer对象内部的value设置为20.(WTF…这里会造成很大的问题…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">f.set(i2,<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>//这里首先会将10进行自动装箱.实际上就是调用Integer.valueOf(10),进而从IntegerCache中找第10个对象.</p><p>//but,第10个对象内部的value还是10么?被上一步改成20了…</p><p>//于是最终就会出现反射debug看到的var1=”20”,var2=”20”了…</p><p>修改结果:失败.</p><p>在揭露正确方法前,先做一个小测验来验证一下前面的结果.</p><p>将f.set(i2, 10);改为f.set(i2, 11);</p><blockquote><p>before a=10,b=20<br>after a=20,b=11</p></blockquote><p>果然…</p><p>那么现在问题就在于不能使用IntegerCache中的对象,因为那个对象已经乱掉了…</p><p>使用f.set(i2, new Integer(10));搞定!</p><p><strong>这个题目其实很坑,因为这样的解法只是为了考验对Integer内部缓存的理解.实际情况中使用这个绝对会得不偿失,带来莫名其妙的问题.</strong></p><p>比如,后面跟着这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer c = <span class="hljs-number">10</span>;<br>System.out.println(c);<br></code></pre></td></tr></table></figure><p>可以看看打印结果…wtf</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CrossWalk-Android Hybrid必备工具</title>
    <link href="/2018/02/03/CrossWalk-Android-Hybrid%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    <url>/2018/02/03/CrossWalk-Android-Hybrid%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>Hybrid就不多说了.除非是到后期各种拼用户体验拼特效拼交互,否则各个公司都要用上一用.</p><p>产品经理:这个可以随便改需求,动态发布,我喜欢.</p><p>android/ios:终于不用做需求了,我们安心研究技术好了.我喜欢</p><p>UI/UX:可以只出一套图了,交互也统一了.我喜欢</p><p>测试:不用两台手机对比着测试了.我喜欢</p><p>前端开发:我屮艸芔茻!</p><p>然而实际使用中,android总是遇到各种问题,兼容性,响应速度等等.</p><p>于是CrossWalk出现了…简单粗暴.直接打包浏览器内核.喜不喜欢?</p><blockquote><p>So,尝(zuo)鲜(si)开始</p></blockquote><p>其实官网上面的使用说明大可不看,各种搭环境,下载依赖的太烦人.直接下载so和jar包吧.</p><p>把这两个文件放到对应位置,直接使用XwalkView替代WebView就可以了.</p><p>看起来似乎很简单?下面是遇到的最大问题:</p><p><strong>包太大了!!!</strong></p><p>一个so文件居然有32M!!!</p><p>32M是什么概念…我一个完整的native应用才5M而已…</p><p>于是使用所谓的Lite版…</p><p>lite版的so文件只有9M.主要是阉割了一些不常用的功能,使用lzma压缩.最终将文件保持在9m多.</p><p>这个还可以接受.</p><p>于是包太大这个问题的解决方案是:</p><blockquote><p>1.使用lite版.<br>2.只打包arm版的so.</p></blockquote><hr><p>前面既然说到lzma压缩.如此高的压缩比也不是没有代价的…代价就是</p><p><strong>解压时间很长!!!</strong></p><p>而且是用到的时候才开始解压!</p><p>在我nexsu5机器上,居然要13秒左右…</p><p>虽说只需要解压一次,但是想象一下.用户第一次打开某个h5模块的时候,要面对一个loading框长达10多秒…</p><p>不能忍…于是查源码.</p><blockquote><p>原来是有一个叫XWalkActivityDelegate的类,onresume方法主要执行两件事,activate和decompress<br>activate主要是加载so的工作在里面.这部分耗时不多.<br>decompress是解压.罪魁祸首就在这一步.</p></blockquote><p>decompress中做了什么事呢?除了漫长的java方法以外,需要重点关注的就是:</p><h4 id="它怎么解压成功之后保存状态-下一次就不需要解压的"><a href="#它怎么解压成功之后保存状态-下一次就不需要解压的" class="headerlink" title="它怎么解压成功之后保存状态,下一次就不需要解压的?"></a>它怎么解压成功之后保存状态,下一次就不需要解压的?</h4><blockquote><p>继续翻源码,原来是SharedPreferences中libxwalkcore.xml里面一个叫version的值.<br>解压完成以后,会设置为5.下次就不用解压,直接activate了.</p></blockquote><p>那我们就在application中开始解压吧.</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><p>复制XWalkLibraryDecompressor,在application的oncreate中就开始解压.</p><hr><p>虽然解压时间提前了,但是还是有很大可能在解压完成之前用户就进入hybrid模块.</p><p>有两种方案:</p><blockquote><p>1.使用loading progress.解压完成以后,再加载h5页面.<br>2.进入时判断解压状态,如果还未解压完成,使用自带webview加载.</p></blockquote><p>考虑之后决定还是使用方案2.主要是解压的进度无法获知.单纯的loading progress用户体验太差.</p><p>真的不能得到解压进度么?如果以百分比显示解压进度不是很好,就不用又回到普通webview上面来了.</p><p>虽然只是第一次进入h5模块的时候可能还未解压完,但是毕竟自带webview问题太多了.也很难跟用户解释这个事情.</p><p>既然解压也是java写的,那就继续扒jar包吧.</p><p>然而这次是无能为力了.lzma解压的java代码写得异常复杂.加上jar包里面命名混乱.再加上对这种算法一无所知.</p><p>复制Decoder类以后还是无法插入代码进行进度回传.</p><p>于是在网上寻找能提供进度显示的lzma解压库.</p><p>然后就发现<a href="https://github.com/hzy3774/AndroidP7zip">这货</a>.使用native方法来解压!</p><p>虽说需要加上一个1.5m的so文件.但是经过试验,解压时间缩短到只需要2<del>3s.因缺斯汀</del></p><p>于是crosswalk包过大的问题算是解决了.</p><blockquote></blockquote><p>1.使用crosswalk-lite.核心so文件降低至9m<br>2.使用native方法进行so文件解压.</p><hr><p>然而第三个(也许是最后一个)问题又来了:</p><p><strong>不支持加载web页面时带上自定义header.</strong></p><p>是不是很坑?估计作者只想到把参数放在url后面.却忽略了天朝重视接口安全的国情.</p><p>好在标准版最近的两个release-19,20中已经加上了对应的代码,支持这个需求了.</p><p>但是lite版号称几个月更新一次.鬼知道什么时候才能跟上这个节奏.也给加上啊…</p><p>看来如果等不及的话,还是要上标准版的节奏…</p><p>于是看看这个lite版到底是怎么变成这么小的:</p><p>可以看到,通过阉割功能带来的体积缩小并不明显.更多的还是通过lzma压缩.</p><p>那么我自己来压缩一下试试?以最高比例压缩模式,通过lzma方式对标准版进行压缩.</p><p>mac上的压缩软件实在没几个好的,压缩过程在windows机器上用7zip工具完成.此处略过</p><p>结果就是:标准版so压缩以后比lite的so大了3.5m…</p><p>那么最终方案来了:</p><p>1.说服前端人员,放弃在加载h5页面时携带自定义header.</p><p>2.使用标准版so,最终apk大约增加4m.(当然,还有可能带来的性能提升,毕竟完整版)</p><p>3.等待lite更新至19以上的版本.(当前标准版的beta分支已经到21,stable分支到了18).<br>具体用哪种,看项目需要吧.</p><p>至此,crosswalk的介绍就暂时结束了.如果有新的坑和进展再来更新.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android中的https使用自生成证书</title>
    <link href="/2018/02/03/android%E4%B8%AD%E7%9A%84https%E4%BD%BF%E7%94%A8%E8%87%AA%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/"/>
    <url>/2018/02/03/android%E4%B8%AD%E7%9A%84https%E4%BD%BF%E7%94%A8%E8%87%AA%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>说起https就得从android app加密说起。</p><p>想hack一个android应用，无非就是反编译和抓包两种办法。</p><p>反编译一般通过加壳和混淆来防止。</p><p>抓包么，就只能通过请求参数加密和https了。</p><h3 id="重点说说https。"><a href="#重点说说https。" class="headerlink" title="重点说说https。"></a>重点说说https。</h3><p>简单来说，https是通过ssl来进行数据加密的http。大致流程如下：</p><blockquote><p>客户端和服务端使用非对称加密进行第一次握手，服务端保留私钥，把公钥发给客户端，客户端首先判断一下这个公钥是否有效，过期，颁发机构什么的。如果没问题，就先生成一个随机值，然后用这个公钥加密，发给服务端，此时只有持有私钥的服务端能解密，于是就得到了这个随机值。现在双方都有同样的随机值了，为后面进行的对称加密传输数据做准备，因为一直用公钥私钥这种非对称的加密太慢了。。。</p></blockquote><p>具体到android 开发中如何实施呢：</p><h4 id="1-首先我们要有个证书："><a href="#1-首先我们要有个证书：" class="headerlink" title="1.首先我们要有个证书："></a>1.首先我们要有个证书：</h4><p>ps：网上铺天盖地那种信任所有证书的方式就不谈了，代码量太少，不专业。&lt;(▰˘◡˘▰)&gt;</p><blockquote><p>keytool -genkey -alias icemantest -keystore fjajfd.keystore -validity 365</p></blockquote><p>后面会让你输入名字，公司，地区，别名，密码，有效时间等等。</p><p>完成之后生成了名叫fjajfd.keystore的一个keystore。这个里面包含私钥。有的android签名用的证书是jks结尾的，也是使用jks证书库的，跟这个差不多。</p><h4 id="2-从keystore里面导出证书，一般-cer这样的。里面包含公钥，这个是可以公开的，谁都可以用来加密，但是只有私钥才能解密。"><a href="#2-从keystore里面导出证书，一般-cer这样的。里面包含公钥，这个是可以公开的，谁都可以用来加密，但是只有私钥才能解密。" class="headerlink" title="2.从keystore里面导出证书，一般.cer这样的。里面包含公钥，这个是可以公开的，谁都可以用来加密，但是只有私钥才能解密。"></a>2.从keystore里面导出证书，一般.cer这样的。里面包含公钥，这个是可以公开的，谁都可以用来加密，但是只有私钥才能解密。</h4><blockquote><p>keytool -export -alias icemantest -keystore fjajfd.keystore -file cer.cer</p></blockquote><p>生成一个叫cer.cer的证书。</p><h4 id="3-android-里面支持的证书是bks证书库格式的，而我们生成的是jks格式的，于是需要转换一下。"><a href="#3-android-里面支持的证书是bks证书库格式的，而我们生成的是jks格式的，于是需要转换一下。" class="headerlink" title="3.android 里面支持的证书是bks证书库格式的，而我们生成的是jks格式的，于是需要转换一下。"></a>3.android 里面支持的证书是bks证书库格式的，而我们生成的是jks格式的，于是需要转换一下。</h4><p>这里需要用到工具bc库bcprov-jdk15on-146.jar。</p><blockquote><p>keytool -import -alias icemantest -file cer.cer -keystore bks.bks -storetype BKS -providerClass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath /Users/iceman/Downloads/bcprov-jdk15on-146.jar</p></blockquote><p>现在bks.bks这个文件就是包含了公钥的android上可以使用的证书了。</p><h3 id="现在以我们应用里面使用的证书举例如何在代码中使用这个证书。"><a href="#现在以我们应用里面使用的证书举例如何在代码中使用这个证书。" class="headerlink" title="现在以我们应用里面使用的证书举例如何在代码中使用这个证书。"></a>现在以我们应用里面使用的证书举例如何在代码中使用这个证书。</h3><p>文件xxx.bks放在raw目录里面，方便直接读取。</p><p>android中一般使用httpurlconnection和httpclient访问网络，这两种情况下使用证书的方式稍有不同，但核心都在一个叫SSLSocketFactory的类上面。</p><h4 id="先说httpurlconnection："><a href="#先说httpurlconnection：" class="headerlink" title="先说httpurlconnection："></a>先说httpurlconnection：</h4><p>主机名验证:</p><p>这个可以使用默认的,看看这句明显是废话的代码就明白了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpsURLConnection.setDefaultHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());<br></code></pre></td></tr></table></figure><p>证书验证:</p><h5 id="第一步-读取公钥信息到keystore中"><a href="#第一步-读取公钥信息到keystore中" class="headerlink" title="第一步:读取公钥信息到keystore中."></a>第一步:读取公钥信息到keystore中.</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> KeyStore <span class="hljs-title">buildKeyStore</span><span class="hljs-params">(Context context, <span class="hljs-keyword">int</span> certRawResId)</span> <span class="hljs-keyword">throws</span> KeyStoreException, CertificateException,NoSuchAlgorithmException, IOException </span>&#123;<br>String keyStoreType = KeyStore.getDefaultType();<br>KeyStore keyStore = KeyStore.getInstance(keyStoreType);<br>InputStream inputStream = context.getResources().openRawResource(certRawResId);<br>keyStore.load(inputStream, <span class="hljs-string">&quot;xxxx&quot;</span>.toCharArray());<br><span class="hljs-keyword">return</span> keyStore;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第二步-使用这个keystore来初始化一个trustmanager-trustmanager简单来说-就是管理是否信任服务端的"><a href="#第二步-使用这个keystore来初始化一个trustmanager-trustmanager简单来说-就是管理是否信任服务端的" class="headerlink" title="第二步:使用这个keystore来初始化一个trustmanager, trustmanager简单来说,就是管理是否信任服务端的."></a>第二步:使用这个keystore来初始化一个trustmanager, trustmanager简单来说,就是管理是否信任服务端的.</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();<br>TrustManagerFactory tmf = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123; <br>tmf = TrustManagerFactory.getInstance(tmfAlgorithm);<br>tmf.init(keyStore);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e)&#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (KeyStoreException e)&#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第三步-使用得到的trustmanager来初始化一个SslContext-进而得到SocketFactory"><a href="#第三步-使用得到的trustmanager来初始化一个SslContext-进而得到SocketFactory" class="headerlink" title="第三步,使用得到的trustmanager来初始化一个SslContext,进而得到SocketFactory:"></a>第三步,使用得到的trustmanager来初始化一个SslContext,进而得到SocketFactory:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">SSLContext sslContext = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>sslContext = SSLContext.getInstance(“TLS”);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e)&#123; <br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>sslContext.init(<span class="hljs-keyword">null</span>, tmf.getTrustManagers(), <span class="hljs-keyword">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (KeyManagementException e) &#123;<br>e.printStackTrace(); &#125; <span class="hljs-keyword">return</span> sslContext.getSocketFactory();<br></code></pre></td></tr></table></figure><p>得到SocketFactory之后就简单了,可以使用HttpsUrlconnetion的静态方法setDefaultSocketFactory来修改默认的,也可以在得到httpsurlconection以后调用setSSLSocketFactory方法来针对每个连接设置.</p><h4 id="然后说说apache的httpclient中使用方法"><a href="#然后说说apache的httpclient中使用方法" class="headerlink" title="然后说说apache的httpclient中使用方法"></a>然后说说apache的httpclient中使用方法</h4><p>读取公钥至keystore跟前者完全一样.</p><p>不同的是apache中也有个SocketFactory类,可以直接用keystore参数来构造,其主机名验证方式也有预设的3个级别:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SSLSocketFactory sf = <span class="hljs-keyword">new</span> SSLSocketFactory(keyStore);<br>sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);<br></code></pre></td></tr></table></figure><p>然后是分别绑定http和https至不同的端口并指定使用的socketfactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SchemeRegistry registry = <span class="hljs-keyword">new</span> SchemeRegistry();<br>registry.register(<span class="hljs-keyword">new</span> Scheme(“http”, PlainSocketFactory.getSocketFactory(), <span class="hljs-number">80</span>));<br>registry.register(<span class="hljs-keyword">new</span> Scheme(“https”, sf, <span class="hljs-number">443</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SingleClientConnManager(getParams(), registry);<br></code></pre></td></tr></table></figure><p>得到上面这个SingleClientConnManager之后,可以继承DefaultHttpClient,重写createClientConnectionManager来返回这个SingleClientConnManager,也可以直接使用这个SingleClientConnManager来构建一个defaultHttpClient.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proguard之keep关键字详解</title>
    <link href="/2018/02/03/Proguard%E4%B9%8Bkeep%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2018/02/03/Proguard%E4%B9%8Bkeep%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="原博客的图片丢失了-所以这是精简版-直接上结论"><a href="#原博客的图片丢失了-所以这是精简版-直接上结论" class="headerlink" title="原博客的图片丢失了,所以这是精简版,直接上结论."></a>原博客的图片丢失了,所以这是精简版,直接上结论.</h3><p>项目很简单,只有两个文件:一个activity+一个普通类.</p><p>ProguardTest</p><p>Activity</p><p>build.gradle.标准配置.使用sdk里面默认+自己的空白配置文件</p><p>先直接混淆一下看看.</p><p>Activity肯定是不混淆的.oncreate方法由于是override也是不混淆的.</p><p>而ProguardTest类的类名,成员名(包括方法名和变量名)都被混淆了.包括内部类也是一样.</p><p>还有一点:类中未使用的方法setName(),直接被移除掉了.</p><hr><p>proguard keep选项的结构:({}内容为必须,[]内容为选用)</p><blockquote><p>{关键字}[类的修饰符]{在哪个类}{keep哪些成员}</p></blockquote><p>下面一条一条试验各个keep关键字的效果.</p><h4 id="keep-class-com-iceman-proguard-ProguardTest"><a href="#keep-class-com-iceman-proguard-ProguardTest" class="headerlink" title="-keep class com.iceman.proguard.ProguardTest{*;}"></a>-keep class com.iceman.proguard.ProguardTest{*;}</h4><p>先套用上面的固定格式解读一下:<br>关键字–keep</p><p>修饰符-无 eg:public</p><p>在哪个类–ProguardTest类</p><p>keep哪些成员-全部</p><p>这个基本没啥好说的.将这个类的名字和成员全部保留起来.未使用的方法setName也保留起来.</p><h4 id="keepnames-class-com-iceman-proguard-ProguardTest"><a href="#keepnames-class-com-iceman-proguard-ProguardTest" class="headerlink" title="-keepnames class com.iceman.proguard.ProguardTest{*;}"></a>-keepnames class com.iceman.proguard.ProguardTest{*;}</h4><p>keepnames<br>区别在哪里?setName方法不见了.</p><p>根据官方的解释keepnames = keep+allowshrinking.即没有用的的类/成员会去除掉.</p><h4 id="keepclassmembers-class-com-iceman-proguard-ProguardTest"><a href="#keepclassmembers-class-com-iceman-proguard-ProguardTest" class="headerlink" title="-keepclassmembers class com.iceman.proguard.ProguardTest{"></a>-keepclassmembers class com.iceman.proguard.ProguardTest{</h4><p>*;}</p><p>只保留成员名字.类本身的名字被混淆.</p><h4 id="keepclassmembernames-class-com-iceman-proguard-ProguardTest"><a href="#keepclassmembernames-class-com-iceman-proguard-ProguardTest" class="headerlink" title="-keepclassmembernames class com.iceman.proguard.ProguardTest{"></a>-keepclassmembernames class com.iceman.proguard.ProguardTest{</h4><p>*;}<br>keepclassmembernames = keepclassmembers+allowshrinking<br>所以此时setName方法会被去除掉.就不截图了.</p><p>下面是重点:keepclasseswithmembers,用两条proguard配置做对比:<br>-keepclasseswithmembers class com.iceman.proguard.ProguardTest{<br>        void method1();}<br>-keepclasseswithmembers class com.iceman.proguard.ProguardTest{<br>void adfadfaf();}</p><p>看来关键在于后面的成员定义这里,</p><p>前者找到method1方法了,然后类名和method1这个方法名被keep了.其他混淆.</p><p>后者没有找到这个方法adfadfaf方法,所以整个类和成员都被混淆了.</p><p>还有加上names的那个.区别参考前面的.names意为去除未使用的.</p><hr><p>总结keep关键字中几个单词的作用:</p><p>names:加上names即允许shrinking.未使用的类/成员会直接去除.不再keep了.</p><p>members:仅仅keep成员,对类自身的名字不再keep.</p><p>withMembers:当指定的成员存在时,keep类名和对应的成员名.否则全部混淆.</p><p>类名定义后面的{;}:大多数情况下为{;}代表keep范围是所有成员,但是如果不写大括号及里面内容的话,keep是不会对成员生效的.仅仅是在某些关键字情况下对类名做keep.<br>实战示例:</p><p>项目中采用了实体类来对应接口返回的json数据.由于使用Gson包做映射,这些实体类的成员变量都是不能混淆的.</p><p>通常采用的方式是:定义一个Unproguard接口.凡是需要保留的类,都继承这个接口.</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">-keepclassmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * <span class="hljs-keyword">implements</span> <span class="hljs-title">rst</span>.<span class="hljs-title">framework</span>.<span class="hljs-title">interfaces</span>.<span class="hljs-title">UnProguard</span></span>&#123;<br>*;<br>&#125;<br></code></pre></td></tr></table></figure><p>可是实际运行后,发现还是统统被混淆了.经过查询原因,发现UnProguard这个类本身也是需要保留的.</p><p>于是加上一条-keep class rst.framework.interfaces.UnProguard后解决.</p><p>混淆keep关键字解析到此结束.更详细的使用文档请参考官网</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android的ImageView之ScaleType效果研究</title>
    <link href="/2018/02/03/android%E7%9A%84ImageView%E4%B9%8BScaleType%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/"/>
    <url>/2018/02/03/android%E7%9A%84ImageView%E4%B9%8BScaleType%E6%95%88%E6%9E%9C%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>这是网络上铺天盖地的scaletype详解:</p><blockquote><p>ImageView的ScaleType决定了图片在View上显示时的样子，如何进行比例缩放，以及显示图片的整体还是部分。<br>如下两种方法：</p></blockquote><h3 id="1-在layout-xml中定义android：ScaleType-”CENTER”"><a href="#1-在layout-xml中定义android：ScaleType-”CENTER”" class="headerlink" title="1. 在layout.xml中定义android：ScaleType=”CENTER”"></a>1. 在layout.xml中定义android：ScaleType=”CENTER”</h3><h3 id="2-在代码中调用imageView-setScaleType-imageView-scaleType-CENTER"><a href="#2-在代码中调用imageView-setScaleType-imageView-scaleType-CENTER" class="headerlink" title="2. 在代码中调用imageView.setScaleType(imageView.scaleType.CENTER);"></a>2. 在代码中调用imageView.setScaleType(imageView.scaleType.CENTER);</h3><p>下面是针对属性的详解：</p><h4 id="1）CENTER"><a href="#1）CENTER" class="headerlink" title="1）CENTER"></a>1）CENTER</h4><p>按图片的原来size 居中显示，当图片长宽超过View的上宽时，则截取图片的居中部分显示</p><h4 id="2）CENTER-CROP"><a href="#2）CENTER-CROP" class="headerlink" title="2）CENTER_CROP"></a>2）CENTER_CROP</h4><p>按比例扩大图片的size 居中显示，使得图片的长宽的等于或大于View的长宽</p><h4 id="3）CENTER-INSIDE"><a href="#3）CENTER-INSIDE" class="headerlink" title="3）CENTER_INSIDE"></a>3）CENTER_INSIDE</h4><p>将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长宽等于或小于view的长宽</p><h4 id="4）FIT-CENTER"><a href="#4）FIT-CENTER" class="headerlink" title="4）FIT_CENTER"></a>4）FIT_CENTER</h4><p>把图片按比例扩大或缩小到View的宽度，然后居中显示</p><h4 id="5）FIT-STAR"><a href="#5）FIT-STAR" class="headerlink" title="5）FIT_STAR"></a>5）FIT_STAR</h4><p>把图片按比例扩大或缩小到View的宽度，然后置顶显示</p><h4 id="6）FIT-END"><a href="#6）FIT-END" class="headerlink" title="6）FIT_END"></a>6）FIT_END</h4><p>把图片按比例扩大或缩小到View的宽度，然后置于底部显示</p><h4 id="7）FIT-XY"><a href="#7）FIT-XY" class="headerlink" title="7）FIT_XY"></a>7）FIT_XY</h4><p>不按比例缩放图片，目标是把整个图片塞满整个View<br>短短几句话实在不能很好理解到底有什么不同,于是我专门在项目中找到不同图片实践对比了一下效果,将结果发上来:</p><h3 id="1-首先确定几个全局规则及定义几个词汇"><a href="#1-首先确定几个全局规则及定义几个词汇" class="headerlink" title="1.首先确定几个全局规则及定义几个词汇:"></a>1.首先确定几个全局规则及定义几个词汇:</h3><p>截取–裁剪图片的一部分用以显示</p><p>截取情况下,所看到的都不会变形.</p><p>fit–在某一方向上进行缩放,直到图片该方向上的两端跟控件一样长为止</p><p>缩小时,先fit的定义为短边</p><p>放大时,先fit的定义为长边</p><p>控件某一方向设置为wrapcontent情况下,该方向上控件大小均等于图片实际大小(会影响到后面的长短边判断)</p><h3 id="2-不同情况下的缩放形式"><a href="#2-不同情况下的缩放形式" class="headerlink" title="2.不同情况下的缩放形式"></a>2.不同情况下的缩放形式</h3><p>centerCrop:只要有一边小于控件大小,则认为是小图</p><p>小图:</p><p>短边先放大至fit,然后从中间截取.</p><p>大图:</p><p>短边先缩小至fit,然后不变形截取</p><p>总结:要让图片在不变形的情况下,完全显示到控件所有地方.</p><hr><p>centerinside:只要有一边大于控件大小,则认为是大图</p><p>小图:</p><p>居中显示,不缩放</p><p>大图:</p><p>长边缩小至fit,居中显示</p><p>总结:要让图片在不变形的情况下,显示全部.可以不撑满控件</p><hr><p>center:只要有一边大于控件大小,则认为是大图</p><p>小图:</p><p>居中显示,不缩放</p><p>大图:</p><p>长边缩小至fit,然后居中</p><p>总结:感觉跟centerInside差不多?</p><hr><p>fitcenter:只要有一边大于控件大小,则认为是大图</p><p>小图:</p><p>长边放大至fit,短边居中</p><p>大图:</p><p>长边缩小至fit,短边居中</p><p>总结:充分展示fit的意思.在此前提下缩放长边,让图片全部显示</p><hr><p>fitstart/fitend:跟fitcenter类似,只不过变成靠头部或者尾部</p><p>这里不说上下是因为根据长边和短边的定义,可能是靠左或者靠右.</p><p>fitxy:双向拉伸图片.撑满控件</p><p>若某一边设置为wrapcontent,则按图片大小来定义控件实际大小</p><hr><p>matrix:使用matrix来缩放图片.</p><p>初始值:图片无缩放,从控件的左上角开始摆放</p><p>小图:剩余部分无图片填充.</p><p>大图:会只显示图片一部分.</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在linux上将默认python2换成python3</title>
    <link href="/2018/02/02/%E5%9C%A8linux%E4%B8%8A%E5%B0%86%E9%BB%98%E8%AE%A4python2%E6%8D%A2%E6%88%90python3/"/>
    <url>/2018/02/02/%E5%9C%A8linux%E4%B8%8A%E5%B0%86%E9%BB%98%E8%AE%A4python2%E6%8D%A2%E6%88%90python3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意：更新python千万不要把老版本的删除！新老版本是可以共存的，很多基本的命令、软件包都要依赖预装的老版本python的，比如yum。</p></blockquote><h2 id="更新python："><a href="#更新python：" class="headerlink" title="更新python："></a>更新python：</h2><h3 id="第1步："><a href="#第1步：" class="headerlink" title="第1步："></a>第1步：</h3><p>更新gcc，因为gcc版本太老会导致新版本python包编译不成功</p><p>#yum -y install gcc</p><p>系统会自动下载并安装或更新，等它自己结束</p><p>安装这四个包…这是安装pip需要的,不然后面pip安装不上.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> zlib<br><br>yum <span class="hljs-keyword">install</span> zlib-devel<br><br>yum <span class="hljs-keyword">install</span> openssl -y<br><br>yum <span class="hljs-keyword">install</span> openssl-devel -y<br></code></pre></td></tr></table></figure><h3 id="第2步："><a href="#第2步：" class="headerlink" title="第2步："></a>第2步：</h3><p>下载Python-3.3.0软件包</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#wget</span> <span class="hljs-selector-tag">http</span>://<span class="hljs-selector-tag">python</span><span class="hljs-selector-class">.org</span>/<span class="hljs-selector-tag">ftp</span>/<span class="hljs-selector-tag">python</span>/3.3.0/<span class="hljs-selector-tag">Python-3</span>.3.0<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bz2</span><br></code></pre></td></tr></table></figure><p>注意：按照上述命令下载的软件包会存放在你当前的工作目录下，wget命令是一个从网络上自动下载文件的自由工具。</p><p>说明：命令中的数字就是版本号，你也可以把3.3.0换成你需要的版本，截止至我撰稿时(2013年1月29日)，最新可用版本是3.3.0</p><h3 id="第3步："><a href="#第3步：" class="headerlink" title="第3步："></a>第3步：</h3><p>解压已下载的二进制包并编译安装</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#tar -jxvf Python-3.3.0.tar.bz2 #cd Python-3.3.0</span><br><br><span class="hljs-meta">#./configure #make all</span><br><br><span class="hljs-meta">#make install</span><br><br><span class="hljs-meta">#make clean</span><br><br><span class="hljs-meta">#make distclean</span><br></code></pre></td></tr></table></figure><p>/usr/local/bin/python3 –V<br>编译安装完毕以后，可以输入上面一行命令，查看版本</p><h3 id="第4步："><a href="#第4步：" class="headerlink" title="第4步："></a>第4步：</h3><p>建立软连接指向到当前系统默认python命令的bin目录让系统使用新版本python</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#mv <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python /u</span>sr<span class="hljs-regexp">/bin/</span>python2.<span class="hljs-number">6</span><span class="hljs-comment">//当前python的版本为2.6所以是python2.6</span><br><br>#ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>python3.<span class="hljs-number">3</span> <span class="hljs-regexp">/usr/</span>bin/python<br><br>#python -V<br></code></pre></td></tr></table></figure><p>即可查看当前默认python版本 默认的python成功指向3.3.0以后，yum不能正常使用，需要修改yum的配置文件</p><h3 id="第5步："><a href="#第5步：" class="headerlink" title="第5步："></a>第5步：</h3><p>修改yum配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#vi <span class="hljs-regexp">/usr/</span>bin/yum<br></code></pre></td></tr></table></figure><p>把文件头部的#!/usr/bin/python改成#!/usr/bin/python2.6 //改为之前的老版本号 保存退出，yum即可正常使用。</p><p>如若有其他命令、软件不能正常使用，仿照yum配置文件的修改方法，修改其配置文件即可。 至此，更新完毕。</p><h3 id="第6步"><a href="#第6步" class="headerlink" title="第6步:"></a>第6步:</h3><p>安装setuptools和pip</p><p>我用的是这两个文件.setuptools-14.0.tar 1.5.5.tar</p><p>解压后,找到setup.py用python命令进行安装即可</p><p>剩下的就可以用pip安装各种插件了.比如pip install Flask</p>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python3操作excel文件</title>
    <link href="/2018/02/02/python3%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6/"/>
    <url>/2018/02/02/python3%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>前段时间遇到一个需求,要从一个有7000多行的excel文件中读取数据.第一反应是python应该能很方便的解析出需要的数据.</p><h3 id="1-python读excel"><a href="#1-python读excel" class="headerlink" title="1.python读excel."></a>1.python读excel.</h3><p>有个叫xlrd的模块.使用pip install xlrd安装即可</p><p>打开一个excel文件:</p><p>data = xlrd.open_workbook(‘xxx.xls’)<br>打开其中一张工作表<br>table = data.sheets()[0] //第一张表</p><p>table = data.sheet_by_index(0) //也是第一张表</p><p>table = data.sheet_by_name(‘Sheet1’) //根据名字获取表<br>得到表的行数和列表<br>table.nrows</p><p>table.ncols<br>得到某行数据或者某列数据,会以数组返回<br>table.row_values(i)<br>table.col_values(i)<br>于是可以这样打印整张表内容<br>for i in range(table.nrows):</p><p>print(table.row_values(i))<br>7000多行瞬间完成.碉堡了.</p><p>获取某个单元格内容,第一个参数是行,第二个为列</p><p>table.cell(0, 1)<br>打印得知里面包含单元格的格式,比如’’number’’,”text”,还有单元格的数据</p><p>直接得到单元格数据可以用</p><p>table.cell(0, 1).value<br>比如某个单元格里面写的”省”</p><p>我调用如下代码</p><p>print(table.cell(0, 1))</p><p>print(table.cell(0, 1).value)<br>显示<br>text:’省’</p><p>省<br>根据行数,列数返回excel中的单元格名字:<br>print(xlrd.cellname(0, 0)) //返回 A1<br>xlrd模块基本上就到这里了.</p><p>虽然网上有这样的方法:</p><p>table.put_cell(13, 5, 0, ‘哈哈’, 0) //写入数据</p><p>print(table.cell(13, 5)) //打印数据,这里确实打印的”哈哈”出来</p><p>data.save(‘xxx.xls’) //运行不会报错,但实际上是没有效果的<br>查资料得知:xlrd是不能修改文件的,前面调用open_workbook返回的是只读的.</p><h3 id="2-python创建excel文件-并写入数据"><a href="#2-python创建excel文件-并写入数据" class="headerlink" title="2.python创建excel文件,并写入数据"></a>2.python创建excel文件,并写入数据</h3><p>对应的模块是xlwt,可惜这个模块是对应python2.x的.还好提供了python3.x的版本.xlwt3.</p><p>使用pip install xlwt3安装</p><p>注意:如果代码运行时出现以下问题:</p><p>ValueError: ‘init‘ in slots conflicts with class variable</p><p>需要修改一下已安装的xlwt3的代码:</p><p>打开Python33Libsite-packagesxlwt3formula.py文件，将其中的</p><p>slots = [“init“, “s”, “parser”, “sheet_refs”, “xcall_refs”]</p><p>修改为</p><p>slots = [ “s”, “parser”, “sheet_refs”, “xcall_refs”]<br>创建一个excel文件<br>wb = xlwt3.Workbook();<br>建立一张表<br>ws = wb.add_sheet(‘A Test Sheet’, cell_overwrite_ok=True);<br>这个cell_overwrite_ok参数比较重要,设定为True的时候,才允许后面的代码中对同一个单元格进行反复写入.</p><p>对单元格进行数据写入</p><p>ws.write(13, 5, 555555);<br>写完保存,记得名字如果与现有的文件一样,就直接覆盖了.(悲剧极易发生)<br>wb.save(‘example.xls’);<br>自定义格式,这里我只试验了定义字体样式.<br>style = xlwt3.XFStyle()</p><p>font = xlwt3.Font()</p><p>font.name = ‘Times New Roman’ //使用Times New Roman字体</p><p>font.bold = True //设置为黑体</p><p>style.font = font<br>然后写入的时候,加上style参数就行了.<br>ws.write(13, 5, 555555, style);</p><h3 id="3-python修改现有excel文件"><a href="#3-python修改现有excel文件" class="headerlink" title="3.python修改现有excel文件"></a>3.python修改现有excel文件</h3><p>使用openpyxl进行xlsx文件的读写编辑操作.python3.x可用.</p>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刚入行时的一次聊天记录</title>
    <link href="/2018/02/02/%E5%88%9A%E5%85%A5%E8%A1%8C%E6%97%B6%E7%9A%84%E4%B8%80%E6%AC%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95/"/>
    <url>/2018/02/02/%E5%88%9A%E5%85%A5%E8%A1%8C%E6%97%B6%E7%9A%84%E4%B8%80%E6%AC%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>iceman 10:50:14</p><p>网络请求的数据返回使用callback形式和使用事件通知形式相比有什么优缺点?<br>携程是callback,我们现在用的localbroadcast通知,<br>同事现在觉得还是callback比较直接,也不用写那么多广播事件的tag来区分.<br>我也觉得callback写起来比较方便,也方便查看代码,但是似乎比较low?因为耦合度太高?<br>小白同学你怎么看?<br>小白 10:53:10</p><p>从效率来说，callback。<br>iceman 10:54:09</p><p>执行效率?<br>小白 10:54:28</p><p>从设计来说，callback比较直接，而且很方便java写匿名内部类，这样发送和接收逻辑基本在一起，方便维护方便调试。</p><p>iceman 10:54:49</p><p>嗯…这是公认的优点<br>小白 10:55:30</p><p>广播需要定义事件id来区分，这势必成为一个全局变量表。全局就是个坑。<br>iceman 10:56:17</p><p>即使使用local的广播?<br>小白 10:56:43</p><p>需要注册、解注册，是无谓的逻辑负担。可以被包装起来自动化处理，但和回调也没有多大区别。<br>小白 10:58:06</p><p>local的广播依然是使用了队列。只不过是在进程内非常快速而已。<br>iceman 10:58:30</p><p>嗯,之前看过一些事件通知的开源项目,eventbus什么的.后来觉得跟android的localbroadcast没啥区别,所以就先用这个通知了.注册和解注册写在基类就好,就是慢慢同事都觉得用起来不方便.<br>小白 10:59:04</p><p>其实，“广播”就已经说明了问题。。。明明不是广播的场景，何必用广播？<br>iceman 10:59:29</p><p>广播就是用于事件通知的啊…网络请求,不也是事件么<br>小白 10:59:36</p><p>就像你想传话给你老婆，非要使用登报、广播、订阅报纸、阅读这一公共渠道，何必。<br>小白 11:01:00</p><p>广播是事件通知的一种没错。但事件通知不止广播这么一种吧？网络请求和响应，反过来就是广播了？<br>iceman 11:02:21</p><p>我是说,事件通知可以用callback,也可以用广播…只不过广播的功能可以更广泛,用于不同页面的,我们目前仅仅是用于当前页面的一些网络事件回传而已…<br>小白 11:02:48</p><p>前提是，如果你有需求。<br>小白 11:03:31</p><p>如果你有需求让发送者不一定是接收者，如果发送接收不一定是一对一关系，那就广播。<br>小白 11:03:51</p><p>而网络请求不符合这个模型。<br>iceman 11:03:57</p><p>嗯.如果可以确定都是一对一关系.那就还是用callback了吧?<br>小白 11:06:23</p><p>理论上广播、消息、总线结构可以做所有事，架构非常灵活。但代价就是，所有成员不管需不需要都得接入总线，这就是成本。总线的结构本身也是成本：比如线程安全、事件驱动等。在复杂模型里这些值得去付出，比如企业级系统里使用JMS。<br>iceman 11:06:26</p><p>嗯,我们之所以有换成callback的原因是:目前的业务和架构在网络请求这个模块上都没有一对多的需求,广播能做的,callback完全能做.<br>有点点小纠结的是:<br>1.广播在别的模块还是有用到,比如确实要一对多的情形,既然这样,何不整成一套呢?总是使用适应性更广的方案,似乎也没错.<br>2.还是那个虚无缥缈的话题,”解耦”的大趋势下…<br>小白 11:10:10</p><p>1，如果需要，那就做。但做出来消息系统可以不包含网络请求和处理，因为网络请求和处理没有这个需求。电脑可以有总线，可以纳入显卡和鼠标这样的极度异构的子系统。但如果显卡渲染单元之间交流都走总线，那就等死吧。。。<br>小白 11:12:03</p><p>2，解耦的目标是可扩展性可维护性，而不是以解得干干净净为目的。干净到变态的极致，那叫过度设计。网上可以搜到用满了23个设计模式的hello world作为模式使用的反例。<br>iceman 11:13:28</p><p>了解了!!可扩展,可维护,那就从callback着手吧.感谢白大神啊.同事一直说要换callback,我还没决定要改,总算能说服自己,开始动手了…<br>小白 11:14:23</p><p>另外，我想起来了，如果是Activities之间传递数据，一个负责发起请求，然后就退到后台或者销毁。然后另一个负责接收处理数据。这种模式确实可以考虑使用总线和消息池。<br>iceman 11:14:58</p><p>嗯.那不属于网络请求嘛.可以再看.情形比较多,就考虑出个方案<br>iceman 11:15:02</p><p>好咯,.干活去咯~<br>小白 11:15:07</p><p>哈哈。<br>小白 11:15:29</p><p>也是网络请求啊。比如说我们公司以前的跳转加载。<br>iceman 11:15:40</p><p>那是坑<br>iceman 11:15:46</p><p>跳转加载并不能增加效率…<br>小白 11:15:51</p><p>为什么？<br>iceman 11:16:11</p><p>在下一个页面的oncreate中开始执行网络请求,并不会慢多少.<br>iceman 11:16:26</p><p>我觉得没有必要为了省这一点点时间,而把架构搞的这么麻烦<br>小白 11:17:00</p><p>主要是。。。你看我们的页面，一个个重的要死，走到oncreate都半天过去了。<br>iceman 11:17:03</p><p>我当初面试的时候说携程的网络请求,说到一个读线程一个写线程,把人家吓尿了…觉得我们好NB<br>iceman 11:17:16</p><p>走到oncreate怎么会半天过去啊<br>iceman 11:17:26</p><p>oncreate那里还没开始页面渲染啊<br>iceman 11:17:38</p><p>基类太重了?<br>小白 11:17:55</p><p>cpu负担，基类，动画。。。各种重。<br>小白 11:18:42</p><p>作用还是有的。但我确实不喜欢使用这么复杂的架构去解决这么小的一个问题。从其他方面优化效果更好。<br>小白 11:18:53</p><p>你们要是不用，那就算了。<br>iceman 11:19:01</p><p>优化一下基类呗..就像当初网络请求的方法重载了10多个一样….哈哈哈,动画嘛.也可以放后面一点<br>iceman 11:19:13</p><p>哈哈..那个得不偿失啊.我们就不用了<br>iceman 11:21:25</p><p>话说我突然想起,那个DialogManager也是一样的道理….小郭把所有界面上需要展示的悬浮控件(单按钮,多按钮,progress,自定义对话框)写到了一起….这个和直接使用某些基类方法,然后传入按钮文字,按钮点击时间监听,优势又在哪里呢?<br>为了可维护性?<br>小白 11:21:40</p><p>蛋。<br>小白 11:21:45</p><p>那是被方法数逼的。<br>iceman 11:21:54</p><p>卧槽…..<br>小白 11:25:41</p><p>哦严格的说，这得分好几个事。<br>1，方法数逼的，不用回调和内隐类，用接口。<br>2，Manager情结，这个好像很多人都有。用对了就算不上错。<br>3，他爱上了builder模式，因为manager集大成了，所以可配置参数太多，所以builder。<br>4，其实正确的姿势是继承、多态和匿名回调。但方法数压力更大。。。<br>iceman 11:26:51</p><p>哈哈哈哈…..方法数…看来在这个压力下,我不能认为携程的都是好的了<br>小白 11:27:52</p><p>所幸这年头这个问题越来越小了。</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用markdown语法</title>
    <link href="/2018/02/01/%E5%B8%B8%E7%94%A8markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2018/02/01/%E5%B8%B8%E7%94%A8markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>##不同等级的标题<br>###不同等级的标题<br>####不同等级的标题<br>#####不同等级的标题<br>######不同等级的标题<br>#######不同等级的标题<br>分割线用—–<br>**加粗加黑**<br>*斜体*<br>&gt;缩进<br>*无序号列表<br>网络图片用![文字](链接)<br>本地图片用hexo专用语法<br><br>文件链接<br><br>超链接[文字](链接)<br>可以打钩的列表<br>- [ ]未打钩<br>- [x]已打勾</p><ul><li>[ ]未打钩</li><li>[x]已打勾<br>代码<br>```java<br>```</li></ul><p>目前常用的就是这个了</p>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo d没反应的问题</title>
    <link href="/2018/02/01/hexo-d%E6%B2%A1%E5%8F%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2018/02/01/hexo-d%E6%B2%A1%E5%8F%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>想重新整理一下github上博客.结果死活deploy不上去.<br>执行hexo d就是没反应.不报错也没输出.</p><h3 id="少了什么插件"><a href="#少了什么插件" class="headerlink" title="少了什么插件?"></a>少了什么插件?</h3><p>按网上的说法尝试安装npm install hexo-deploy-git –save.由于事情已经过去了,插件名字可能没写对,反正装上去了也没用.</p><h3 id="必须使用https的git地址-用户名密码"><a href="#必须使用https的git地址-用户名密码" class="headerlink" title="必须使用https的git地址+用户名密码?"></a>必须使用https的git地址+用户名密码?</h3><p>虽说教程都是用https,但是deploy节点中配置的也就是一个标准的git remote信息,ssh的方式应该不至于用不了,而且用ssh部署也是有先例的.</p><p>最后在v2ex上一篇文章最后一个评论中找到答案…原来是空格问题.</p><p>于是我在每个字段前面加个两个空格,搞定.</p><p>这尼玛,语法要求这么严格!!!</p>]]></content>
    
    
    <categories>
      
      <category>杂技</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
